<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>如何被写进恐怖故事里 · 结果页</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js"></script>
  <style>
    html,body{margin:0;height:100%;background:#000;color:#ffecec;font-family:ui-monospace,monospace}
    canvas{display:block}
  </style>
</head>
<body>
<script>
/*==================== 读取答题结果 ====================*/
const payload = (()=>{ try{ return JSON.parse(localStorage.getItem('quizPayload')||'{}'); }catch(e){ return {}; } })();
const ans = payload.answers || {};
let aHit=null; for(let i=1;i<=6;i++){ if(ans['AA'+i]==='是'){ aHit='A'+i; break; } }
let bHit=null; for(let i=1;i<=6;i++){ if(ans['B'+i]==='是'){ bHit='B'+i; break; } }
const cHit = ans['C1'] ? 'C1' : null;

// 选择故事优先级：先 B（若有 C1 也选 B），再 A，再 C1
let storyKey=null;
if(bHit){ storyKey=bHit; }
else if(aHit){ storyKey=aHit; }
else if(cHit){ storyKey=cHit; }

/*==================== 故事模板 ====================*/
const STORIES = {
  A1: {
    title: "那个女人",
    text: `[Aname]第一次来我们办公室的时候，大家都说她很有礼貌，说话轻声细语，穿着合身，笑起来像谁都不会拒绝的人。领导很喜欢她，说她“像我们这行该有的样子”。
[Aname]从不迟到，桌子永远整整齐齐，午饭吃得不多，话也不多。有时候我偷偷看她自拍：角度永远一样，下巴朝镜头对齐，[A1a特征][A1c特征]
她和谁都处得很好，只是没人见过她真正生气，或者真正开心。她每一次笑都像是按下某种按钮才启动的。[A1b特征]
有天晚上我们加班，办公室只剩我和[Aname]。我走过去想问她要不要一起走，结果看到她正在镜子前低头调整什么。不是妆容，不是衣领——是脸。
她把脸从脸上慢慢剥下来，从额头撕开，再一寸一寸地卷到下巴。里面是空的。只有白白的塑料架子，像模特头。
她回头的时候，那张脸正挂在手里，可她还在笑。和照片里一模一样的笑。`
  },
  A2: {
    title: "影子靠得太近",
    text: `刚认识[Aname]的时候，我只觉得[Aname]人很好。[Aname]总是替我占座，记得我爱吃什么，把细枝末节都放在心上。我和[Aname]是同一个性别，所以我以为，这只是普通朋友的关心。可渐渐地，我发现哪里不对。[Aname]看我的时间太久了，[A2a特征]
有时我转开头，[Aname]的眼神还挂在我身上，像影子黏住一样。有时别人说起“正常”这个词，[Aname]就会忽然[A2b特征]
有一次，有人开玩笑问[Aname]喜欢谁。[A2c特征]
那一刻，空气忽然沉下来，我不敢呼吸。
后来大家都在说：
“[Aname]会靠太近。”
“[Aname]会跟着你回家。”
“要是被[Aname]盯上，就躲不掉。”
我开始睡不安稳。半夜醒来，总觉得[Aname]的呼吸在枕边。有一次，我清楚地感觉到，有手从被子底下伸进来，冰冷而湿，一点点往我身上爬。我一抬头，[Aname]正趴在床沿，脸离我只有一寸远。`
  },
  A3: {
    title: "楼道里的数数声",
    text: `孩子们在楼下跳皮筋时，会唱一首歌：
“有病人，脸色白，
影子歪，走得怪。
楼口数着一二三，
看见你，就跟你来。
门口脚印湿漉漉，
会问一句：‘是不是你？’
别回答，别出声，
回了话，就没了人。”
大人们听见都皱眉，说孩子胡闹。
可大家都知道，这歌唱的就是楼里那个生了病的人，[Aname]。[A3c特征][A3b特征]
[Aname]总坐在楼梯口，像是在等什么，[A3a特征]
去年冬天，我回到家时听见孩子们的歌声在空荡的楼道里回荡。
我循着声音走到三楼，看见[Aname]正蹲在台阶上，嘴里一下一下数着：“一……二……三……”
脚边的地垫全是湿的，脚印一直延伸到门口。
我想转身离开，可背后传来一句轻轻的声音：
“是不是你？”`
  },
  A4: {
    title: "缝一张“本地脸”",
    text: `他们说城里最近出现了一个人，没有人知道那人的确切名字，那人自言自语时总会反复低声念一个像“[Aname]”的音节，于是人们就用她称呼那人。没人知道[Aname]是从哪儿来的，只知道[Aname]在这座城市没有任何亲人，也没有留下任何地址。
有人说在夜里听见过[Aname]的声音，[A4a特征]，像是隔着很远的山谷传来的。有人说在街口碰见[Aname]时，第一眼记住的就是[A4b特征]，让人觉得很怪异。[Aname]走过人群时，总带着一股[A4c特征]，仿佛提醒大家，[Aname]并不属于这里。
传言里最令人不安的是：[Aname]曾在废弃的房子里被看见过，用针线缝补什么东西。有人悄悄跟过去，发现[Aname]正把一块干裂的皮肤摊开——有人发誓那是本地人才会有的肤色。有人说见过[Aname]半夜坐在石桥下，手里反复摩挲一张什么东西，像是晒干的皮革。再靠近时，[Aname]却把那东西贴到脸上，慢慢抬起头。
后来，城里孩子常常莫名失踪。有人怀疑，是跟[Aname]走了。有人说，[Aname]只是想缝出一张真正“属于这里”的脸。`
  },
  A5: {
    title: "那张永远在写字的桌子",
    text: `家里其实一直有四个人。只是父母后来再也不提起那一个。
我记得[Aname]很安静。吃饭时不说话，作业写得极整齐，犯错时就低头。后来有一天，[Aname]不见了。父母说[Aname]去了外地，可我在晚上总会听见[Aname]的房间里传来写字的声音，尖锐到像是刀子刮纸。
某个夜里，我推开那扇门。里面空无一人，桌上却摊着一本作业本。纸张湿漉漉的，上面一行字被反复写烂，渗出褐色的痕迹：[A5a特征]。
我不敢再看，转身要走，却发现房间镜子里“我”的嘴在说话。可仔细看那张脸并不是我，是[Aname]。[Aname]眼眶发黑，嘴唇裂开，手里死死攥着[A5c特征]，像是一直没放下。
[Aname]开口时，声音却是父母的语调：[A5b特征]。每吐出一个字，[Aname]嘴里的血就滴到地板上，迅速扩散成一摊带着墨味腥气的黑水，把我的脚死死黏住。我拼命喊，可家里没人回应。饭桌上的父母只是微笑着夹菜，仿佛什么都没听见。
从那以后，我的房间每晚都会多出一张课桌，上面坐着[Aname]。[Aname]的手腕上全是深深的勒痕，可笔尖仍在动。每当我想说话，[Aname]就抬起头，用没有眼白的眼睛盯着我。
父母越来越满意，说我最近懂事了许多。可我知道，那不是因为我乖了，而是因为[Aname]一直坐在我旁边——替我把所有“不听话的声音”写了下来。
有时候，我觉得[Aname]并不是来害我。[Aname]只是想来告诉我自己从来没有真正离开过。
这所房子，本来就埋着两个孩子。`
  },
  A6: {
    title: "练习册上的名字",
    text: `班上有个同学叫[Aname]，总是一个人。
[Aname]总坐在[A6b特征]，[A6a特征]，没人会主动和[Aname]说话。[Aname]很少说话，但常常[A6c特征]。起初，大家只是觉得[Aname]有点奇怪。可时间久了，总有人发现，自己在写字的时候，会突然觉得背后有双眼睛盯着。回头时，[Aname]正低着头，像什么都没发生过。
有一次午休，教室里忽然传出一声沉闷的撞击。等大家冲进去时，只看见一个同学脸色惨白地坐在地上，手还在抖。桌子翻倒，地上全是纸屑。[Aname]就站在旁边，表情没有变化，嘴角甚至还停留着那种笑。老师追问，可那同学一句话都说不出来，只是死死盯着[Aname]。而[Aname]弯下腰，把散落的纸屑一点点拾起，整齐塞进书包。
从那以后，大家都尽量避开[Aname]。可即便隔得很远，总有人在课间突然僵住，说好像听见耳边有极轻的呼吸声。等猛地回头，[Aname]就在那里，笔尖一下一下描着同一个字。
后来，有人翻过[Aname]的练习册。上面密密麻麻写的，都是班里同学的名字。`
  },
  B1: {
    title: "伴侣不在时的房间",
    text: `我一直以为自己遇到了完美的伴侣。我的伴侣总是记得我所有的偏好，出门时牵着我的手，夜里贴在我耳边叫我的名字：“[Aname]”那种被需要的感觉让我彻底沉溺。
可最近我常常感觉有些不对劲。[B1a特征]
有几个晚上，我听到身边传来细微的响动，回头看见[B1b特征]
昨晚我半夜惊醒，屋子静得像空的，我的身边空无一人，[B1c特征]。我慢慢走到客厅，感觉地上好像有什么东西在爬。紧接着，我看见一个人影把身体一点点折叠，四肢像被生硬地拧断又拼接，背脊高高拱起，手脚并用地沿着墙面缓慢爬行。骨头在皮下顶出不正常的角度，关节“咔”的一声错开又对上，渗出的血在地板上拉出一条发黑的线。
那个人影一点点朝我爬过来，我仿佛被钉在了地上，想跑但一丝一毫都动不了。那个人抬起头时，是我无比熟悉的那张脸！可那张脸的下颌被拉得很长，嘴角裂开，血顺着牙缝滴落，仍旧在低声叫我：“[Aname]——”`
  },
  B2: {
    title: "外乡人",
    text: `[Aname]一直过着安静的生活。可最近，城里传出了奇怪的议论。
人们说，这里来了一个外乡人。没人知道他从哪儿来，只知道他在这座城市没有任何亲人，也没有留下任何地址。[Aname]走过人群时，总带着一股说不出的异味，[B2c特征]
某个夜晚，[Aname]走在回家的街道上。街灯昏暗，路面空荡，身后突然传来一阵奇怪的声音，[B2a特征][Aname]转头看见那个外乡人立在不远处的路灯下，[B2b特征]
不知道为什么像被神秘力量驱使着一样，[Aname]屏住呼吸，悄悄跟了上去。外乡人拐进一栋废弃的房子。门缝透出昏黄的光，映出佝偻的背影。他用针线缝补什么东西。有人悄悄跟过去，发现他正把一块干裂的皮肤摊开——那是本地人才会有的肤色。他把那块皮肤在手里反复摩挲着，接着把那东西贴到脸上，慢慢抬起头。皮肤贴合的一瞬，缝隙里渗出黑红的液体。
[Aname]的喉咙发紧，空气像灌满了铁锈的腥味。[Aname]想退开，却发现背后已经贴在冰冷的墙上。那双眼睛没有移开，只在他脸上缓慢停留——安静得像在挑选下一张要取下的皮。`
  },
  C1: {
    title: "夜",
    text: (()=> {
      const v = ans['C1'] || '';
      if (v.includes('中式女鬼')) {
        return `夜色沉沉，[Aname]独自走过荒废的巷子。风从破损的木门缝里钻出，吹灭了手里的火柴。黑暗中，耳边忽然传来低低的哭声，像是女子在哀诉。
顺着声音望去，巷口的石狮旁站着一个白衣女子。衣摆在无风的夜里轻轻飘动，脚下却没有影子。她的头缓缓抬起，脸色惨白如纸，唇角却涂着鲜红，笑意僵硬。
[Aname]屏住呼吸，转身想离开，身后却传来“嗒——嗒——”的脚步声，节奏缓慢而沉重。明明没有人走路，那声音却愈发逼近。余光里，女子的衣角擦过墙壁，却没有触到地面。
忽然，女子抬起头，唇齿间缓慢吐出[Aname]的名字，一字一顿，像是在招魂。冷风猛地灌入巷子，火柴熄灭，四周陷入死寂。白影定在面前一寸，红唇大张，没有牙齿，只有漆黑的洞。`;
      } else if (v.includes('吸血鬼')) {
        return `月光透过窗棂洒在[Aname]的房间里，冷白得像一层薄纱。手机黑屏中，忽然浮现出一张陌生的面孔——眼睛泛着血色光芒，嘴角露出锋利的獠牙。
[Aname]愣在原地，心跳声被放大到整个房间都能听见。窗没有开，门没有响，可床边已经多出一个高大的身影。冰凉的手指在颈侧滑过，像在寻找血管的位置。
灯光骤然熄灭，黑暗里传来低语：“别害怕，很快你就不需要心跳了。”下一秒，獠牙划破空气，血液像被提前召唤，从[Aname]的脖颈奔涌而出，注向那张渴求的嘴。`;
      } else {
        return `半夜醒来，[Aname]觉得房间安静得过分。手机屏幕黑着，却映出床边一个模糊的轮廓。盯久了，那影子缓缓蠕动，像是正慢慢靠近。
呼吸里混入另一种节奏，比[Aname]的更沉重、更冰冷。木板咯吱作响，每一步都踩在胸口。肩膀逐渐下沉，像被无形的重量压住。想要翻身，身体却僵硬得像被钉死在床上。
灯光闪烁的一瞬间，墙壁上浮现出一团黑雾般的面孔，没有眼睛，没有嘴巴，却紧贴在耳边。随即，冰凉的气息顺着耳道钻入大脑，模糊的低语在脑海里反复回荡——不属于[Aname]，却越来越像是[Aname]的声音。`;
      }
    })()
  }
};

/*==================== 构建故事并做占位符替换 ====================*/
function buildStoryParagraphs(){
  const story = STORIES[storyKey];
  if(!story) return ['（没有找到对应故事模板）'];
  let txt = story.text;

  const userName = (payload.name && String(payload.name).trim()) || '参与者';
  txt = txt.replaceAll('[Aname]', userName);

  if(storyKey === 'A1'){
    txt = txt.replaceAll('[A1a特征]', ans['A1a']||'')
             .replaceAll('[A1b特征]', ans['A1b']||'')
             .replaceAll('[A1c特征]', ans['A1c']||'');
  }

  const rep = (k)=>{ if(ans[k]) txt = txt.replaceAll(`[${k}特征]`, ans[k]); };
  switch(storyKey){
    case 'A2': ['A2a','A2b','A2c'].forEach(rep); break;
    case 'A3': ['A3a','A3b','A3c'].forEach(rep); break;
    case 'A4': ['A4a','A4b','A4c'].forEach(rep); break;
    case 'A5': ['A5a','A5b','A5c'].forEach(rep); break;
    case 'A6': ['A6a','A6b','A6c'].forEach(rep); break;
    case 'B1': ['B1a','B1b','B1c'].forEach(rep); break;
    case 'B2': ['B2a','B2b','B2c'].forEach(rep); break;
    case 'C1': break;
  }

  if(storyKey !== 'A1'){
    txt = txt.replace(/她/g, userName);
  }

  return txt.split('\n').map(s=>s.trim()).filter(Boolean);
}
let paragraphs = buildStoryParagraphs();

/*==================== 标题 ====================*/
let WOMAN_TEXT = (STORIES[storyKey]?.title) || '未命名故事';

/*==================== 视觉资源 ====================*/
function pickGlitchPath(key){
  if(!key) return null;
  if(/^A/.test(key)) return 'assets/glitch_A1.gif';
  if(/^B/.test(key)) return 'assets/glitch_A1.gif';
  return 'assets/glitch_B1.gif';
}
const EYE_IMAGE_PATH='assets/eyes.png';
const GLITCH_IMAGE_PATH = pickGlitchPath(storyKey);

/*==================== 布局与绘制 ====================*/
const RIGHT_RATIO=0.56, SAFE_TOP=20, SAFE_RIGHT=30, SAFE_BOTTOM=24, GUTTER=24;
const WRAP_WIDTH_RATIO=0.92;
const BASE={title:96, para:18, padX:10, padY:4, gap:12};
const MIN ={title:24, para:12, padX:6, padY:2, gap:8 };
const LEAD={title:1.05, para:0.98};
let S={...BASE};
const BOX_FILL=[210,20,20], BOX_ALPHA=220, TEXT_RGB=[255,255,255];
const SHADOW_ALPHA=40, SHADOW_OFFSET=2;
const TEAR_INTENSITY=2.0, TEAR_SCALE=0.03, TEAR_ALPHA=35;
let rightRect={x:0,y:0,w:0,h:0};

let video,mosaicBuffer,mosaicTick=0;
let eyesImg=null, eyes=[]; const EYE_COUNT=7;

let glitchStill=null,glitchKeyed=null,glitchOn=false,glitchFrames=0;
const GLITCH={ALPHA:245, PROB:0.006, MIN:28, MAX:46, KEY:true, TH:28, SOFT:24};

function preload(){
  if(GLITCH_IMAGE_PATH){ glitchStill=loadImage(GLITCH_IMAGE_PATH,()=>{},()=>glitchStill=null); }
  eyesImg = loadImage(EYE_IMAGE_PATH,()=>{},()=>{ eyesImg=null; });
}
function setup(){
  createCanvas(windowWidth, windowHeight); textAlign(LEFT,TOP);
  video=createCapture(VIDEO); video.size(floor(width/10), floor(height/10)); video.hide();
  mosaicBuffer=createGraphics(width,height); mosaicBuffer.noStroke();
  updateLayout(); autosizeToFit(); initEyes();
}
function windowResized(){
  resizeCanvas(windowWidth, windowHeight);
  mosaicBuffer=createGraphics(width,height); mosaicBuffer.noStroke();
  if(video) video.size(floor(width/10),floor(height/10));
  updateLayout(); autosizeToFit(); initEyes();
}
function draw(){
  background(0); drawMosaicBackground(); darkenBG(45);
  maybeFlashGlitch(); if(!glitchOn) drawEyes();
  ribbonEdges.length=0;
  drawRightColumn(true);     // 第一次：收集红框底边
  drawRightColumn(false);    // 第二次：真的把红框画出来
  bleedRibbons();            // 原有：文字框底边渗血
  bleedMouse();              // 新增：鼠标划过即出血（最上层）
}

function drawMosaicBackground(){
  if(mosaicTick%3===0){
    mosaicBuffer.clear(); video.loadPixels();
    const step=10, levels=6, a=255, minG=20, maxG=170;
    for(let y=0;y<video.height;y++){
      for(let x=0;x<video.width;x++){
        const idx=(x+y*video.width)*4;
        const q=map(floor(map((video.pixels[idx]+video.pixels[idx+1]+video.pixels[idx+2])/3,0,255,0,levels)),0,levels-1,minG,maxG);
        mosaicBuffer.fill(q,a); mosaicBuffer.rect(x*step,y*step,step,step);
      }
    }
  }
  mosaicTick++; image(mosaicBuffer,0,0,width,height);
}
function darkenBG(a){ noStroke(); fill(0,a); rect(0,0,width,height); }

function maybeFlashGlitch(){
  if(!glitchStill) return;
  if(!glitchOn && random()<GLITCH.PROB){ glitchOn=true; glitchFrames=int(random(GLITCH.MIN,GLITCH.MAX+1)); initEyes(); }
  if(glitchOn){
    push(); tint(255,GLITCH.ALPHA);
    const img=(GLITCH.KEY? (glitchKeyed||(glitchKeyed=keyOutBlack(glitchStill,GLITCH.TH,GLITCH.SOFT))) : glitchStill);
    const cs=min(width,height), sc=cs/min(img.width,img.height), dw=img.width*sc, dh=img.height*sc;
    image(img,(width-dw)/2,(height-dh)/2,dw,dh); pop();
    if(--glitchFrames<=0) glitchOn=false;
  }
}
function keyOutBlack(src,thr=28,soft=24){
  const out=createImage(src.width,src.height); out.copy(src,0,0,src.width,src.height,0,0,src.width,src.height);
  out.loadPixels(); const n=out.width*out.height;
  for(let i=0;i<n;i++){ const idx=i*4, r=out.pixels[idx],g=out.pixels[idx+1],b=out.pixels[idx+2],a0=out.pixels[idx+3], br=(r+g+b)/3;
    out.pixels[idx+3]=(br<=thr)?0:(br<thr+soft? a0*((br-thr)/soft) : a0);
  } out.updatePixels(); return out;
}
function initEyes(){
  eyes=[]; if(!eyesImg) return;
  for(let i=0;i<EYE_COUNT;i++){
    const m=40, x=random(m,width-m), y=random(m,height-m), w=random(90,140)*(width/1280*0.9+0.55), h=w*(eyesImg.height/eyesImg.width);
    eyes.push({x,y,w,h, amp:random(4,10), spd:random(0.015,0.035), ph:random(TWO_PI), rotAmp:random(-0.06,0.06)});
  }
}
function drawEyes(){
  if(!eyesImg || !eyes.length) return;
  imageMode(CENTER);
  for(const e of eyes){
    const dy=sin(frameCount*e.spd+e.ph)*e.amp, dx=cos(frameCount*e.spd*0.8+e.ph)*e.amp*0.35;
    push(); translate(e.x+dx,e.y+dy); rotate(sin(frameCount*e.spd*0.6+e.ph)*e.rotAmp); image(eyesImg,0,0,e.w,e.h); pop();
  }
  imageMode(CORNER);
}

/*==================== 文本布局（右栏） ====================*/
const RIGHT_W = ()=> rightRect.w*WRAP_WIDTH_RATIO;
function updateLayout(){
  const rx=floor(width*RIGHT_RATIO)+GUTTER, rw=Math.max(220,width-rx-SAFE_RIGHT);
  rightRect={x:rx,y:SAFE_TOP,w:rw,h:height-SAFE_TOP-SAFE_BOTTOM};
}
function wrapLines(s,maxW,fontSize){
  textSize(fontSize);
  const hasSpace=/\s/.test(s);
  const hasCJK=/[\u3040-\u30ff\u3400-\u9fff\uf900-\ufaff]/.test(s);
  let lines=[''];
  if(hasCJK || !hasSpace){
    for(const ch of Array.from(s)){
      const cur=lines[lines.length-1];
      const candidate=cur+ch;
      if(textWidth(candidate)<=maxW || cur==='') lines[lines.length-1]=candidate;
      else lines.push(ch);
    }
  }else{
    for(const tk of s.split(/(\s+)/)){
      const cur=lines[lines.length-1];
      const candidate=cur+tk;
      if(textWidth(candidate)<=maxW || cur==='') lines[lines.length-1]=candidate;
      else lines.push(tk.trimStart());
    }
  }
  return lines.map(v=>v.replace(/\s+$/,''));
}
function autosizeToFit(){
  S={...BASE};
  for(let it=0; it<40; it++){
    const need=estimateHeight(S);
    if(need<=rightRect.h) break;
    const ratio=Math.max(0.5, rightRect.h/need*0.97);
    S.title=Math.max(MIN.title, Math.floor(S.title*ratio));
    S.para =Math.max(MIN.para , Math.floor(S.para *ratio));
    S.padX=Math.max(MIN.padX , Math.floor(S.padX*ratio));
    S.padY=Math.max(MIN.padY , Math.floor(S.padY*ratio));
    S.gap =Math.max(MIN.gap , Math.floor(S.gap*ratio));
  }
}
function estimateHeight(sz){
  const w=RIGHT_W();
  const tLines=wrapLines(WOMAN_TEXT,w,sz.title);
  const tBoxH=(sz.title*LEAD.title+2*sz.padY)*tLines.length;
  let h=tBoxH+sz.gap*1.2;
  for(const p of paragraphs){
    const lines=wrapLines(p,w,sz.para);
    const boxH=(sz.para*LEAD.para+2*sz.padY)*lines.length;
    h+=boxH+sz.gap;
  }
  return h;
}
let ribbonEdges=[];
function drawRightColumn(collect=true){
  const w=RIGHT_W(); let y=rightRect.y;
  textFont('monospace'); textSize(S.title); textLeading(S.title*LEAD.title);
  const tLines=wrapLines(WOMAN_TEXT,w,S.title);
  y=drawRibbonBlock(tLines,rightRect.x,y,S.title*LEAD.title,S.padX,S.padY,BOX_FILL,BOX_ALPHA,[255,255,255],collect);
  y+=S.gap*1.2;
  textFont('monospace'); textSize(S.para); textLeading(S.para*LEAD.para);
  for(const p of paragraphs){
    const lines=wrapLines(p,w,S.para);
    y=drawRibbonBlock(lines,rightRect.x,y,S.para*LEAD.para,S.padX,S.padY,BOX_FILL,BOX_ALPHA,TEXT_RGB,collect);
    y+=S.gap;
  }
}
function drawRibbonBlock(lines,x,y,leading,padX,padY,fillRGB,fillAlpha,textRGB,collectEdges){
  const boxH=leading+padY*2;
  const widths=lines.map(s=>Math.max(1,textWidth(s)));
  const maxW=RIGHT_W();
  const boxWs=widths.map(w=>Math.min(w+padX*2, maxW));
  drawRibbonShape(x+SHADOW_OFFSET,y+SHADOW_OFFSET,boxWs,boxH,color(0,SHADOW_ALPHA),null);
  drawRibbonShape(x,y,boxWs,boxH,color(fillRGB[0],fillRGB[1],fillRGB[2],fillAlpha),{tear:true});
  fill(textRGB[0],textRGB[1],textRGB[2]); noStroke();
  for(let i=0;i<lines.length;i++){ const ty=y+i*boxH+padY; text(lines[i], x+padX, ty); }
  if(collectEdges) collectRibbonBottomEdges(x,y,boxWs,boxH);
  return y+lines.length*boxH;
}
function drawRibbonShape(x,y,boxWs,boxH,fillCol,opt={tear:false}){
  const pts=buildRibbonOutline(x,y,boxWs,boxH);
  noStroke(); fill(fillCol); beginShape(); for(const p of pts) vertex(p.x,p.y); endShape(CLOSE);
  if(opt&&opt.tear){
    noFill(); stroke(255,TEAR_ALPHA); strokeWeight(2);
    beginShape();
    for(const p of pts){
      const jx=(noise(p.x*TEAR_SCALE,p.y*TEAR_SCALE)-.5)*2*TEAR_INTENSITY;
      const jy=(noise(p.x*TEAR_SCALE+999,p.y*TEAR_SCALE+999)-.5)*2*TEAR_INTENSITY;
      vertex(p.x+jx,p.y+jy);
    }
    endShape(CLOSE);
  }
}
function buildRibbonOutline(x,y,boxWs,boxH){
  const n=boxWs.length, pts=[]; pts.push({x:x,y:y}); pts.push({x:x+boxWs[0],y:y});
  for(let i=0;i<n;i++){ pts.push({x:x+boxWs[i],y:y+(i+1)*boxH}); if(i<n-1) pts.push({x:x+boxWs[i+1],y:y+(i+1)*boxH}); }
  pts.push({x:x,y:y+n*boxH}); pts.push({x:x,y:y}); return pts;
}
function collectRibbonBottomEdges(x,y,boxWs,boxH){
  const n=boxWs.length;
  for(let i=0;i<n-1;i++){ if(boxWs[i]>boxWs[i+1]) ribbonEdges.push({x1:x+boxWs[i+1],x2:x+boxWs[i],y:y+(i+1)*boxH}); }
  ribbonEdges.push({x1:x,x2:x+boxWs[n-1],y:y+n*boxH});
}

/*==================== 原有：出血（从红框底边） ====================*/
const R={
  ENABLED:true,
  DELAY:90,
  DENSITY:0.00012,
  MAX:240,
  VMIN:0.035, VMAX:0.08,
  LEN_MIN:80, LEN_MAX:360,
  THICK_MIN:6, THICK_MAX:8,
  WOBBLE:0.85, ALPHA:230
};
let ribbonDrips=[];
function bleedRibbons(){
  if(!R.ENABLED) return;
  if(!this._started){ if(frameCount-R.DELAY>0){ this._started=true; } else return; }
  for(const seg of ribbonEdges){
    const L=Math.max(0,seg.x2-seg.x1); if(L<=0) continue;
    const expected=L*R.DENSITY, n=Math.floor(expected), prob=expected-n;
    let count=n+(Math.random()<prob?1:0); count=Math.min(count,Math.max(0),R.MAX-ribbonDrips.length);
    for(let k=0;k<count;k++){
      const x=random(seg.x1+.5, seg.x2-.5), y0=seg.y+1, maxLen=Math.max(0,height-y0-6);
      ribbonDrips.push({x,y0,head:0,len:constrain(random(R.LEN_MIN,R.LEN_MAX),12,maxLen),
        speed:random(R.VMIN,R.VMAX),thick:random(R.THICK_MIN,R.THICK_MAX),seed:random(1000)});
      if(ribbonDrips.length>=R.MAX) break;
    }
    if(ribbonDrips.length>=R.MAX) break;
  }
  noStroke();
  for(let i=ribbonDrips.length-1;i>=0;i--){
    const d=ribbonDrips[i]; d.speed*=1.01; d.head+=d.speed;
    const segH=3;
    for(let yy=0; yy<d.head && yy<d.len; yy+=segH){
      const t=yy/d.len, w=lerp(d.thick,d.thick*0.65,t), wob=(noise(d.seed+yy*0.05+frameCount*0.02)-.5)*2*R.WOBBLE;
      fill(BOX_FILL[0],BOX_FILL[1],BOX_FILL[2],R.ALPHA); rect(d.x+wob-w/2, d.y0+yy, w, segH);
    }
    const wobHead=(noise(d.seed+d.head*0.05+frameCount*0.02)-.5)*2*R.WOBBLE;
    fill(BOX_FILL[0],BOX_FILL[1],BOX_FILL[2],Math.min(255,R.ALPHA+10)); ellipse(d.x+wobHead, d.y0+d.head, d.thick*1.2, d.thick*1.2);
    if(d.head>d.len) ribbonDrips.splice(i,1);
  }
}

/*==================== 新增：鼠标划过即出血 ====================*/
const MOUSE_BLOOD = {
  ENABLED: true,
  STEP_DIST: 18,      // 鼠标每移动超过该距离就生成一次
  DRIPS_PER_SPAWN: [8,14], // 每次生成若干条
  LEN: [70, 260],
  SPEED: [0.06, 0.12],
  THICK: [5, 9],
  WOBBLE: 1.1,
  ALPHA: 235,
  PUDDLE: {          // 起始处渗开的血迹
    R0: 4,           // 初始半径
    Rv: [0.25,0.6],  // 扩散速度
    LIFE: [110,180], // 寿命（帧）
    OPACITY: 95
  },
  MAX_TOTAL: 600     // 全局上限，保证性能
};

let mouseDrips = [];
let mousePuddles = [];
let _lastSpawnX = null, _lastSpawnY = null;

function mouseMoved(){ spawnMouseBlood(mouseX, mouseY); }
function mouseDragged(){ spawnMouseBlood(mouseX, mouseY); }
// 触摸端
function touchMoved(){ spawnMouseBlood(mouseX || touches[0]?.x || 0, mouseY || touches[0]?.y || 0); return false; }

function spawnMouseBlood(x,y){
  if(!MOUSE_BLOOD.ENABLED) return;
  if(x==null||y==null) return;
  if(_lastSpawnX==null){ _lastSpawnX=x; _lastSpawnY=y; }
  const dx=x-_lastSpawnX, dy=y-_lastSpawnY;
  if(Math.hypot(dx,dy) < MOUSE_BLOOD.STEP_DIST) return;
  _lastSpawnX=x; _lastSpawnY=y;

  // 生成血线
  let n = floor(random(MOUSE_BLOOD.DRIPS_PER_SPAWN[0], MOUSE_BLOOD.DRIPS_PER_SPAWN[1]+1));
  // 不要超过上限
  n = Math.min(n, Math.max(0, MOUSE_BLOOD.MAX_TOTAL - mouseDrips.length));
  for(let i=0;i<n;i++){
    const jitterX = random(-14,14);
    const len = random(MOUSE_BLOOD.LEN[0], MOUSE_BLOOD.LEN[1]);
    const spd = random(MOUSE_BLOOD.SPEED[0], MOUSE_BLOOD.SPEED[1]);
    const thick = random(MOUSE_BLOOD.THICK[0], MOUSE_BLOOD.THICK[1]);
    mouseDrips.push({
      x: constrain(x + jitterX, 2, width-2),
      y0: constrain(y + random(-2,2), 0, height-6),
      head: 0,
      len: Math.min(len, Math.max(12, height - y - 6)),
      speed: spd,
      thick: thick,
      seed: random(1000)
    });
  }

  // 生成起始渗开
  mousePuddles.push({
    x: x, y: y,
    r: MOUSE_BLOOD.PUDDLE.R0,
    rv: random(MOUSE_BLOOD.PUDDLE.Rv[0], MOUSE_BLOOD.PUDDLE.Rv[1]),
    life: floor(random(MOUSE_BLOOD.PUDDLE.LIFE[0], MOUSE_BLOOD.PUDDLE.LIFE[1])),
  });
  // 控制渗开上限
  if(mousePuddles.length>200) mousePuddles.splice(0, mousePuddles.length-200);
}

function bleedMouse(){
  if(!MOUSE_BLOOD.ENABLED) return;

  // 画渗开的“血滩”
  noStroke();
  for(let i=mousePuddles.length-1;i>=0;i--){
    const p = mousePuddles[i];
    const t = 1 - p.life / Math.max(1, MOUSE_BLOOD.PUDDLE.LIFE[1]);
    const alpha = MOUSE_BLOOD.PUDDLE.OPACITY * (0.7 + 0.3*(1-t));
    fill(BOX_FILL[0],BOX_FILL[1],BOX_FILL[2], alpha);
    // 用几个同心椭圆做出“水渍+毛边”的感觉
    ellipse(p.x, p.y, p.r*2, p.r*2);
    ellipse(p.x+noise(p.x*0.03, frameCount*0.01)*2-1, p.y+noise(p.y*0.03, frameCount*0.012)*2-1, p.r*1.5, p.r*1.5);
    p.r += p.rv;
    p.life--;
    if(p.life<=0) mousePuddles.splice(i,1);
  }

  // 画血线下垂
  noStroke();
  for(let i=mouseDrips.length-1;i>=0;i--){
    const d = mouseDrips[i];
    d.speed *= 1.012;          // 轻微加速
    d.head  += d.speed;
    const segH=3;
    for(let yy=0; yy<d.head && yy<d.len; yy+=segH){
      const t=yy/d.len, w=lerp(d.thick, d.thick*0.62, t);
      const wob=(noise(d.seed+yy*0.05+frameCount*0.02)-.5)*2*MOUSE_BLOOD.WOBBLE;
      fill(BOX_FILL[0],BOX_FILL[1],BOX_FILL[2], MOUSE_BLOOD.ALPHA);
      rect(d.x+wob-w/2, d.y0+yy, w, segH);
    }
    const wobHead=(noise(d.seed+d.head*0.05+frameCount*0.02)-.5)*2*MOUSE_BLOOD.WOBBLE;
    fill(BOX_FILL[0],BOX_FILL[1],BOX_FILL[2], Math.min(255, MOUSE_BLOOD.ALPHA+12));
    ellipse(d.x+wobHead, d.y0+d.head, d.thick*1.15, d.thick*1.15);
    if(d.head>d.len) mouseDrips.splice(i,1);
  }
}
</script>
</body>
</html>
