<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>如何被写进恐怖故事里 · 结果页</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/addons/p5.dom.min.js"></script>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#000; color:#ffecec;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      overflow:hidden; /* 禁止页面滚动，画布始终全屏 */
    }
    canvas { display:block; }
  </style>
</head>
<body>
<script>
/*==================== 读取答题结果 → 选故事键 ====================*/
const payload = (()=>{ try { return JSON.parse(localStorage.getItem('quizPayload')||'{}'); } catch(e){ return {}; } })();
const nameValue = payload.name || '参与者';
const ans = payload.answers || {};

let aHit=null; for(let i=1;i<=6;i++){ if(ans['AA'+i]==='是'){ aHit='A'+i; break; } }
let bHit=null; for(let i=1;i<=6;i++){ if(ans['B'+i]==='是'){ bHit='B'+i; break; } }
const cHit = ans['C1'] ? 'C1' : null;

let storyKey=null, storyLabel='';
if(bHit && cHit){ storyKey=bHit; storyLabel='焦虑原型 '+bHit; }
else if(aHit){ storyKey=aHit; storyLabel='身份原型 '+aHit; }
else if(bHit){ storyKey=bHit; storyLabel='焦虑原型 '+bHit; }
else if(cHit){ storyKey=cHit; storyLabel='伪归类 C1'; }

/*==================== 故事模板（先留空，A1示例） ====================*/
const T = {
  A1: `她第一次来我们办公室的时候，大家都说她很有礼貌，说话轻声细语，穿着合身，笑起来像谁都不会拒绝的人。
领导很喜欢她，说她“像我们这行该有的样子”。她从不迟到，桌子永远整整齐齐，午饭吃得不多，话也不多。
有时候我偷偷看她自拍：角度永远一样，下巴朝镜头对齐，[A1a特征]，[A1c特征]。
她和谁都处得很好，只是没人见过她真正生气，或者真正开心。她每一次笑都像是按下某种按钮才启动的。[A1b特征]。
有天晚上我们加班，办公室只剩我和她。我走过去想问她要不要一起走，结果看到她正在镜子前低头调整什么。不是妆容，不是衣领——是脸。
她把脸从脸上慢慢剥下来，从额头撕开，再一寸一寸地卷到下巴。里面是空的。只有白白的塑料架子，像模特头。
她回头的时候，那张脸正挂在手里，可她还在笑。和照片里一模一样的笑。`,
  A2:``,A3:``,A4:``,A5:``,A6:``,
  B1:``,B2:``,B3:``,B4:``,B5:``,B6:``,
  C1:``
};

function buildStoryParagraphs(){
  let key=storyKey; if(!key || !T[key]) return ['（没有找到对应故事模板，请补充 15 篇文本或返回重试）'];
  let txt=T[key];
  if(key.startsWith('A')){
    txt = txt.replaceAll(`[${key}a特征]`, ans[key+'a']||'')
             .replaceAll(`[${key}b特征]`, ans[key+'b']||'')
             .replaceAll(`[${key}c特征]`, ans[key+'c']||'');
  } else if(key.startsWith('B')){
    txt = txt.replaceAll(`[${key}a]`, ans[key+'a']||'')
             .replaceAll(`[${key}b]`, ans[key+'b']||'')
             .replaceAll(`[${key}c]`, ans[key+'c']||'');
  } else if(key==='C1'){
    txt = (T[key]||'').replaceAll('[C1选项]', ans['C1']||'');
  }
  return txt.split('\n').map(s=>s.trim());
}

/*==================== 15 张故障图与故事键映射 ====================*/
const GLITCH_MAP = {
  A1:'assets/glitch_A1.gif', A2:'assets/glitch_A2.gif', A3:'assets/glitch_A3.gif', A4:'assets/glitch_A4.gif', A5:'assets/glitch_A5.gif', A6:'assets/glitch_A6.gif',
  B1:'assets/glitch_B1.gif', B2:'assets/glitch_B2.gif', B3:'assets/glitch_B3.gif', B4:'assets/glitch_B4.gif', B5:'assets/glitch_B5.gif', B6:'assets/glitch_B6.gif',
  C1:'assets/glitch_C1.gif'
};

/*==================== 你的视觉（eye 层保留；glitch 随故事） ====================*/
// 字体 / 资源
let fontPath="fonts.ttf", WOMAN_FONT_PATH="SpecialElite-Regular.ttf";
let USE_GLITCH_IMAGE = true;
let GLITCH_IMAGE_PATH = GLITCH_MAP[storyKey] || 'assets/glitch_default.gif';

// eye 层（所有故事统一素材）
let EYE_IMAGE_PATH = 'assets/eyes.png';
let EYE_COUNT = 7;

// 马赛克
let RESOLUTION=10, ASCII_UPDATE_INTERVAL=3, MOSAIC_LEVELS=6, MOSAIC_ALPHA=255, MOSAIC_MIN_GRAY=20, MOSAIC_MAX_GRAY=170, BG_DARKEN_ALPHA=45;

// glitch（闪现）
let GLITCH_IMAGE_ALPHA=245, GLITCH_FLASH_PROB=0.015, GLITCH_MIN_FRAMES=15, GLITCH_MAX_FRAMES=30;
let KEY_OUT_BLACK=true, KEY_BLACK_THRESHOLD=28, KEY_BLACK_SOFTNESS=24;

// 右侧丝带
let RIGHT_RATIO=0.56, SAFE_TOP=30, SAFE_RIGHT=30, SAFE_BOTTOM=30, GUTTER=24;
let WOMAN_TEXT = storyLabel || 'woman', WOMAN_SIZE=96, WOMAN_LINE_H=1.05, WOMAN_PAD_X=14, WOMAN_PAD_Y=8, WOMAN_COLOR=[255,255,255];
let PARA_SIZE=16, PARA_LINE_H=1.25, PARA_PAD_X=12, PARA_PAD_Y=8, PARA_GAP=12, BOX_FILL=[210,20,20], BOX_ALPHA=220, TEXT_COLOR=[255,255,255], SHADOW_ALPHA=40, SHADOW_OFFSET=2;
let TEAR_INTENSITY=2.0, TEAR_SCALE=0.03, TEAR_ALPHA=35, WRAP_WIDTH_RATIO=0.95;

// 出血
let RIBBON_BLEED_ENABLED=true, RIBBON_BLEED_DELAY_FRAMES=200, RIBBON_SPAWN_DENSITY=0.00010, RIBBON_DRIP_MAX=350,
    RIBBON_DRIP_SPEED_MIN=0.05, RIBBON_DRIP_SPEED_MAX=0.2, RIBBON_DRIP_LEN_MIN=80, RIBBON_DRIP_LEN_MAX=380,
    RIBBON_DRIP_THICK_MIN=7, RIBBON_DRIP_THICK_MAX=8, RIBBON_DRIP_WOBBLE=0.85, RIBBON_DRIP_ALPHA=230;

// 运行变量
let customFont, womanFont, video, mosaicBuffer, mosaicTick=0, glitchStill=null, glitchKeyed=null, glitchOn=false, glitchFramesLeft=0;
let rightRect={x:0,y:0,w:0,h:0}, paragraphs=buildStoryParagraphs();
let ribbonEdges=[], ribbonDrips=[], ribbonBleedStart=0, ribbonBleedStarted=false;
// eye 层
let eyeImg=null, eyes=[];

// —— 预加载
function preload(){
  try{ customFont=loadFont(fontPath);}catch(e){}
  try{ womanFont=loadFont(WOMAN_FONT_PATH);}catch(e){}
  if(USE_GLITCH_IMAGE) glitchStill = loadImage(GLITCH_IMAGE_PATH);
  eyeImg = loadImage(EYE_IMAGE_PATH, ()=>{}, ()=>{ eyeImg=null; });
}

// —— 初始化
function setup(){
  createCanvas(windowWidth, windowHeight);
  if(customFont) textFont(customFont); textAlign(LEFT,TOP);
  video = createCapture(VIDEO); video.size(floor(width/RESOLUTION), floor(height/RESOLUTION)); video.hide();
  mosaicBuffer = createGraphics(width,height); mosaicBuffer.noStroke();
  if(USE_GLITCH_IMAGE && KEY_OUT_BLACK && glitchStill){ glitchKeyed = keyOutBlack(glitchStill, KEY_BLACK_THRESHOLD, KEY_BLACK_SOFTNESS); }
  updateLayout(); ribbonBleedStart=frameCount; initEyes();
  autosizeParagraphs(); // 初次适配
}

// —— 每帧
function draw(){
  background(0);
  drawMosaicBackground();
  if(BG_DARKEN_ALPHA>0){ noStroke(); fill(0,BG_DARKEN_ALPHA); rect(0,0,width,height); }
  if(!glitchOn) drawEyes();
  maybeFlashGlitchImage();
  ribbonEdges.length=0; drawRightColumn(true);
  if(RIBBON_BLEED_ENABLED) bleedRibbons();
  drawRightColumn(false);
}

/* === 背景马赛克 === */
function drawMosaicBackground(){
  if(mosaicTick % ASCII_UPDATE_INTERVAL === 0){
    mosaicBuffer.clear(); video.loadPixels();
    for(let y=0;y<video.height;y++){
      for(let x=0;x<video.width;x++){
        const idx=(x+y*video.width)*4;
        const r=video.pixels[idx], g=video.pixels[idx+1], b=video.pixels[idx+2];
        const bright=(r+g+b)/3;
        const level=floor(map(bright,0,255,0,MOSAIC_LEVELS));
        const q=map(level,0,MOSAIC_LEVELS-1,MOSAIC_MIN_GRAY,MOSAIC_MAX_GRAY);
        mosaicBuffer.fill(q,MOSAIC_ALPHA);
        mosaicBuffer.rect(x*RESOLUTION,y*RESOLUTION,RESOLUTION,RESOLUTION);
      }
    }
  }
  mosaicTick++; image(mosaicBuffer,0,0);
}

/* === glitch 闪现（抠黑） === */
function maybeFlashGlitchImage(){
  if(!USE_GLITCH_IMAGE || !glitchStill) return;
  if(!glitchOn && random()<GLITCH_FLASH_PROB){ glitchOn=true; glitchFramesLeft=floor(random(GLITCH_MIN_FRAMES,GLITCH_MAX_FRAMES+1)); }
  if(glitchOn){
    push(); tint(255,GLITCH_IMAGE_ALPHA);
    const img=(KEY_OUT_BLACK && glitchKeyed)?glitchKeyed:glitchStill;
    const cs=min(width,height), is=min(img.width,img.height), sc=cs/is, dw=img.width*sc, dh=img.height*sc, dx=(width-dw)/2, dy=(height-dh)/2;
    image(img,dx,dy,dw,dh); pop();
    if(--glitchFramesLeft<=0) glitchOn=false;
  }
}

/* === 自动适配：根据可用高度缩小段落字号 === */
function estimateRightHeight(womanLines, paraLines){
  const titleBoxH = WOMAN_SIZE + PARA_PAD_Y*2;
  const paraBoxH  = PARA_SIZE  + PARA_PAD_Y*2;
  return womanLines.length*titleBoxH + PARA_GAP*1.2 + paraLines.reduce((s,ls)=> s + ls.length*paraBoxH + PARA_GAP, 0);
}
function autosizeParagraphs(){
  const wrapW = rightRect.w * WRAP_WIDTH_RATIO;
  textSize(WOMAN_SIZE);
  const womanLines = wrapLines(WOMAN_TEXT, wrapW, WOMAN_SIZE);
  textSize(PARA_SIZE);
  let paraLines = paragraphs.map(p => wrapLines(p, wrapW, PARA_SIZE));
  let h = estimateRightHeight(womanLines, paraLines);
  while (h > rightRect.h && PARA_SIZE > 12){
    PARA_SIZE -= 1;
    textSize(PARA_SIZE);
    paraLines = paragraphs.map(p => wrapLines(p, wrapW, PARA_SIZE));
    h = estimateRightHeight(womanLines, paraLines);
  }
  window.__womanLines = womanLines;
  window.__paraLines  = paraLines;
}

/* === 右侧丝带 === */
function drawRightColumn(collect=true){
  updateLayout();
  autosizeParagraphs(); // 尺寸或内容改变时重算
  let cursorY=rightRect.y;

  if(womanFont) textFont(womanFont); else textFont('monospace');
  textSize(WOMAN_SIZE); textLeading(WOMAN_SIZE*WOMAN_LINE_H);
  const titleLines = window.__womanLines;
  cursorY = drawRibbonBlock(titleLines, rightRect.x, cursorY, WOMAN_SIZE, WOMAN_PAD_X, WOMAN_PAD_Y, BOX_FILL, BOX_ALPHA, [255,255,255], collect);
  cursorY += PARA_GAP*1.2;

  if(customFont) textFont(customFont); else textFont('monospace');
  textSize(PARA_SIZE); textLeading(PARA_SIZE*PARA_LINE_H);
  const paraLines = window.__paraLines;
  for(let i=0;i<paraLines.length;i++){
    const lines = paraLines[i];
    cursorY = drawRibbonBlock(lines, rightRect.x, cursorY, PARA_SIZE, PARA_PAD_X, PARA_PAD_Y, BOX_FILL, BOX_ALPHA, TEXT_COLOR, collect);
    cursorY += PARA_GAP;
  }
}
function drawRibbonBlock(lines,x,y,fontSize,padX,padY,fillRGB,fillAlpha,textRGB,collectEdges){
  const widths=lines.map(s=>max(1,textWidth(s.replace(/\s+$/,''))));
  const boxWs=widths.map(w=>w+padX*2), boxH=fontSize+padY*2;
  drawRibbonShape(x+SHADOW_OFFSET,y+SHADOW_OFFSET,boxWs,boxH,color(0,SHADOW_ALPHA),null);
  drawRibbonShape(x,y,boxWs,boxH,color(fillRGB[0],fillRGB[1],fillRGB[2],fillAlpha),{tear:true});
  fill(textRGB[0],textRGB[1],textRGB[2]); noStroke();
  for(let i=0;i<lines.length;i++){ const s=lines[i].replace(/\s+$/,''); const ty=y+padY+i*boxH; text(s,x+padX,ty); }
  if(collectEdges) collectRibbonBottomEdges(x,y,boxWs,boxH);
  return y+lines.length*boxH;
}
function drawRibbonShape(x,y,boxWs,boxH,fillCol,opt={tear:false}){
  const pts=buildRibbonOutline(x,y,boxWs,boxH);
  noStroke(); fill(fillCol); beginShape(); for(const p of pts) vertex(p.x,p.y); endShape(CLOSE);
  if(opt&&opt.tear){ noFill(); stroke(255,TEAR_ALPHA); strokeWeight(2); beginShape();
    for(const p of pts){ const jx=(noise(p.x*TEAR_SCALE,p.y*TEAR_SCALE)-.5)*2*TEAR_INTENSITY;
      const jy=(noise(p.x*TEAR_SCALE+999,p.y*TEAR_SCALE+999)-.5)*2*TEAR_INTENSITY; vertex(p.x+jx,p.y+jy); }
    endShape(CLOSE);
  }
}
function buildRibbonOutline(x,y,boxWs,boxH){
  const n=boxWs.length, pts=[]; pts.push({x:x,y:y}); pts.push({x:x+boxWs[0],y:y});
  for(let i=0;i<n;i++){ pts.push({x:x+boxWs[i],y:y+(i+1)*boxH}); if(i<n-1) pts.push({x:x+boxWs[i+1],y:y+(i+1)*boxH}); }
  pts.push({x:x,y:y+n*boxH}); pts.push({x:x,y:y}); return pts;
}
function collectRibbonBottomEdges(x,y,boxWs,boxH){
  const n=boxWs.length;
  for(let i=0;i<n-1;i++){ if(boxWs[i]>boxWs[i+1]){ const yEdge=y+(i+1)*boxH, x1=x+boxWs[i+1], x2=x+boxWs[i]; ribbonEdges.push({x1,x2,y:yEdge}); } }
  const yBottom=y+n*boxH; ribbonEdges.push({x1:x,x2:x+boxWs[n-1],y:yBottom});
}

/* === 出血 === */
function bleedRibbons(){
  if(!ribbonBleedStarted){ if(frameCount-ribbonBleedStart>=RIBBON_BLEED_DELAY_FRAMES) ribbonBleedStarted=true; else return; }
  for(const seg of ribbonEdges){
    const L=max(0,seg.x2-seg.x1); if(L<=0) continue;
    const expected=L*RIBBON_SPAWN_DENSITY, n=floor(expected), prob=expected-n;
    let count=n+(random()<prob?1:0); count=min(count,max(0,RIBBON_DRIP_MAX-ribbonDrips.length));
    for(let k=0;k<count;k++){
      const x=random(seg.x1+.5, seg.x2-.5), y0=seg.y+1, maxLen=max(0,height-y0-6);
      const len=constrain(random(RIBBON_DRIP_LEN_MIN,RIBBON_DRIP_LEN_MAX),12,maxLen);
      ribbonDrips.push({ x,y0, head:0, len, speed:random(RIBBON_DRIP_SPEED_MIN,RIBBON_DRIP_SPEED_MAX),
        thick:random(RIBBON_DRIP_THICK_MIN,RIBBON_DRIP_THICK_MAX), seed:random(1000) });
      if(ribbonDrips.length>=RIBBON_DRIP_MAX) break;
    }
    if(ribbonDrips.length>=RIBBON_DRIP_MAX) break;
  }
  noStroke();
  for(let i=ribbonDrips.length-1;i>=0;i--){
    const d=ribbonDrips[i]; d.speed*=1.01; d.head+=d.speed;
    const segH=3;
    for(let yy=0; yy<d.head && yy<d.len; yy+=segH){
      const t=yy/d.len, w=lerp(d.thick,d.thick*0.65,t);
      const wob=(noise(d.seed+yy*0.05+frameCount*0.02)-.5)*2*RIBBON_DRIP_WOBBLE;
      fill(BOX_FILL[0],BOX_FILL[1],BOX_FILL[2],RIBBON_DRIP_ALPHA); rect(d.x+wob-w/2, d.y0+yy, w, segH);
    }
    const wobHead=(noise(d.seed+d.head*0.05+frameCount*0.02)-.5)*2*RIBBON_DRIP_WOBBLE;
    fill(BOX_FILL[0],BOX_FILL[1],BOX_FILL[2],min(255,RIBBON_DRIP_ALPHA+10)); ellipse(d.x+wobHead, d.y0+d.head, d.thick*1.2, d.thick*1.2);
    if(d.head>d.len) ribbonDrips.splice(i,1);
  }
}

/* === 眼睛层（所有故事统一素材） === */
function initEyes(){
  eyes=[]; if(!eyeImg) return;
  for(let i=0;i<EYE_COUNT;i++){
    const margin=40, x=random(margin,width-margin), y=random(margin,height-margin);
    const targetW = random(90,140)*(width/1280 * 0.9 + 0.55);
    const targetH = targetW * (eyeImg.height/eyeImg.width);
    eyes.push({ baseX:x, baseY:y, w:targetW, h:targetH, amp:random(4,10), spd:random(0.015,0.035), phase:random(TWO_PI), rotAmp:random(-0.06,0.06)});
  }
}
function drawEyes(){
  if(!eyeImg || eyes.length===0) return;
  push(); imageMode(CENTER);
  for(const e of eyes){
    const dy=sin(frameCount*e.spd+e.phase)*e.amp, dx=cos(frameCount*e.spd*0.8+e.phase)*e.amp*0.35, rot=sin(frameCount*e.spd*0.6+e.phase)*e.rotAmp;
    push(); translate(e.baseX+dx, e.baseY+dy); rotate(rot); image(eyeImg,0,0,e.w,e.h); pop();
  }
  pop();
}

/* === 工具 === */
function wrapLines(textStr, maxW, fontSize){
  const tokens=textStr.split(/(\s+)/); let lines=['']; textSize(fontSize);
  for(const tk of tokens){ const trial=lines[lines.length-1]+tk;
    if(textWidth(trial)<=maxW || lines[lines.length-1]===''){ lines[lines.length-1]=trial; }
    else { lines.push(tk.trimStart()); } }
  return lines.map(s=>s.replace(/\s+$/,''));
}
function updateLayout(){
  const rightX=floor(width*RIGHT_RATIO)+GUTTER, rightW=max(220,width-rightX-SAFE_RIGHT), rightY=SAFE_TOP, rightH=height-SAFE_TOP-SAFE_BOTTOM;
  rightRect={x:rightX,y:rightY,w:rightW,h:rightH};
}
function keyOutBlack(srcImg, threshold=28, softness=24){
  let keyed=createImage(srcImg.width, srcImg.height);
  keyed.copy(srcImg,0,0,srcImg.width,srcImg.height,0,0,srcImg.width,srcImg.height);
  keyed.loadPixels();
  const n=keyed.width*keyed.height;
  for(let i=0;i<n;i++){
    const idx=i*4, r=keyed.pixels[idx], g=keyed.pixels[idx+1], b=keyed.pixels[idx+2], a0=keyed.pixels[idx+3], bright=(r+g+b)/3;
    if(bright<=threshold) keyed.pixels[idx+3]=0;
    else if(softness>0 && bright<threshold+softness){ const t=(bright-threshold)/softness; keyed.pixels[idx+3]=a0*t; }
  }
  keyed.updatePixels(); return keyed;
}
function windowResized(){
  resizeCanvas(windowWidth, windowHeight);
  mosaicBuffer=createGraphics(width,height); mosaicBuffer.noStroke();
  if(video) video.size(floor(width/RESOLUTION), floor(height/RESOLUTION));
  updateLayout(); initEyes(); autosizeParagraphs();
}
</script>
</body>
</html>
    txt = (T[key]||'').replaceAll('[C1选项]', ans['C1']||'');
  }
  return txt.split('\n').map(s=>s.trim());
}

/*==================== 故障图映射（15 张） ====================*/
const GLITCH_MAP = {
  A1:'assets/glitch_A1.gif', A2:'assets/glitch_A2.gif', A3:'assets/glitch_A3.gif', A4:'assets/glitch_A4.gif', A5:'assets/glitch_A5.gif', A6:'assets/glitch_A6.gif',
  B1:'assets/glitch_B1.gif', B2:'assets/glitch_B2.gif', B3:'assets/glitch_B3.gif', B4:'assets/glitch_B4.gif', B5:'assets/glitch_B5.gif', B6:'assets/glitch_B6.gif',
  C1:'assets/glitch_C1.gif'
};

/*==================== 视觉：保持你的版式 ====================*/
// 可选字体（没有就留空）
let fontPath=null, WOMAN_FONT_PATH=null;
// glitch 图与 eye 图
let USE_GLITCH_IMAGE=true;
let GLITCH_IMAGE_PATH = GLITCH_MAP[storyKey] || 'assets/glitch_C1.gif';
let EYE_IMAGE_PATH='assets/eyes.png', EYE_COUNT=7;

// 马赛克/丝带/出血参数（与你一致）
let RESOLUTION=10, ASCII_UPDATE_INTERVAL=3, MOSAIC_LEVELS=6, MOSAIC_ALPHA=255, MOSAIC_MIN_GRAY=20, MOSAIC_MAX_GRAY=170, BG_DARKEN_ALPHA=45;
let GLITCH_IMAGE_ALPHA=245, GLITCH_FLASH_PROB=0.015, GLITCH_MIN_FRAMES=15, GLITCH_MAX_FRAMES=30, KEY_OUT_BLACK=true, KEY_BLACK_THRESHOLD=28, KEY_BLACK_SOFTNESS=24;
let RIGHT_RATIO=0.56, SAFE_TOP=30, SAFE_RIGHT=30, SAFE_BOTTOM=30, GUTTER=24;
let WOMAN_TEXT=storyLabel||'woman', WOMAN_SIZE=96, WOMAN_LINE_H=1.05, WOMAN_PAD_X=14, WOMAN_PAD_Y=8, WOMAN_COLOR=[255,255,255];
let PARA_SIZE=16, PARA_LINE_H=1.25, PARA_PAD_X=12, PARA_PAD_Y=8, PARA_GAP=12, BOX_FILL=[210,20,20], BOX_ALPHA=220, TEXT_COLOR=[255,255,255], SHADOW_ALPHA=40, SHADOW_OFFSET=2;
let TEAR_INTENSITY=2.0, TEAR_SCALE=0.03, TEAR_ALPHA=35, WRAP_WIDTH_RATIO=0.95;
let RIBBON_BLEED_ENABLED=true, RIBBON_BLEED_DELAY_FRAMES=200, RIBBON_SPAWN_DENSITY=0.00010, RIBBON_DRIP_MAX=350,
    RIBBON_DRIP_SPEED_MIN=0.05, RIBBON_DRIP_SPEED_MAX=0.2, RIBBON_DRIP_LEN_MIN=80, RIBBON_DRIP_LEN_MAX=380,
    RIBBON_DRIP_THICK_MIN=7, RIBBON_DRIP_THICK_MAX=8, RIBBON_DRIP_WOBBLE=0.85, RIBBON_DRIP_ALPHA=230;

// 运行变量
let customFont, womanFont, video, mosaicBuffer, mosaicTick=0, glitchStill=null, glitchKeyed=null, glitchOn=false, glitchFramesLeft=0;
let rightRect={x:0,y:0,w:0,h:0}, paragraphs=buildStoryParagraphs();
let ribbonEdges=[], ribbonDrips=[], ribbonBleedStart=0, ribbonBleedStarted=false;
let eyeImg=null, eyes=[];

// 预加载
function preload(){
  try{ if(fontPath) customFont=loadFont(fontPath);}catch(e){}
  try{ if(WOMAN_FONT_PATH) womanFont=loadFont(WOMAN_FONT_PATH);}catch(e){}
  if(USE_GLITCH_IMAGE) glitchStill = loadImage(GLITCH_IMAGE_PATH);
  eyeImg = loadImage(EYE_IMAGE_PATH, ()=>{}, ()=>{ eyeImg=null; });
}

function setup(){
  createCanvas(windowWidth, windowHeight);
  if(customFont) textFont(customFont);
  textAlign(LEFT,TOP);
  video = createCapture(VIDEO); video.size(floor(width/RESOLUTION), floor(height/RESOLUTION)); video.hide();
  mosaicBuffer = createGraphics(width,height); mosaicBuffer.noStroke();
  if(USE_GLITCH_IMAGE && KEY_OUT_BLACK && glitchStill){ glitchKeyed = keyOutBlack(glitchStill, KEY_BLACK_THRESHOLD, KEY_BLACK_SOFTNESS); }
  updateLayout(); ribbonBleedStart=frameCount; initEyes();
}

function draw(){
  background(0);
  drawMosaicBackground();
  if(BG_DARKEN_ALPHA>0){ noStroke(); fill(0,BG_DARKEN_ALPHA); rect(0,0,width,height); }
  if(!glitchOn) drawEyes();
  maybeFlashGlitchImage();
  ribbonEdges.length=0; drawRightColumn(true);
  if(RIBBON_BLEED_ENABLED) bleedRibbons();
  drawRightColumn(false);
}

/* 背景马赛克 */
function drawMosaicBackground(){
  if(mosaicTick % ASCII_UPDATE_INTERVAL === 0){
    mosaicBuffer.clear(); video.loadPixels();
    for(let y=0;y<video.height;y++){
      for(let x=0;x<video.width;x++){
        const idx=(x+y*video.width)*4;
        const r=video.pixels[idx], g=video.pixels[idx+1], b=video.pixels[idx+2];
        const bright=(r+g+b)/3;
        const level=floor(map(bright,0,255,0,MOSAIC_LEVELS));
        const q=map(level,0,MOSAIC_LEVELS-1,MOSAIC_MIN_GRAY,MOSAIC_MAX_GRAY);
        mosaicBuffer.fill(q,MOSAIC_ALPHA);
        mosaicBuffer.rect(x*RESOLUTION,y*RESOLUTION,RESOLUTION,RESOLUTION);
      }
    }
  }
  mosaicTick++; image(mosaicBuffer,0,0);
}

/* glitch 闪现（抠黑） */
function maybeFlashGlitchImage(){
  if(!USE_GLITCH_IMAGE || !glitchStill) return;
  if(!glitchOn && random()<GLITCH_FLASH_PROB){ glitchOn=true; glitchFramesLeft=floor(random(GLITCH_MIN_FRAMES,GLITCH_MAX_FRAMES+1)); }
  if(glitchOn){
    push(); tint(255,GLITCH_IMAGE_ALPHA); const img=(KEY_OUT_BLACK && glitchKeyed)?glitchKeyed:glitchStill;
    const cs=min(width,height), is=min(img.width,img.height), sc=cs/is, dw=img.width*sc, dh=img.height*sc, dx=(width-dw)/2, dy=(height-dh)/2;
    image(img,dx,dy,dw,dh); pop();
    if(--glitchFramesLeft<=0) glitchOn=false;
  }
}

/* 右侧丝带+文字 */
function drawRightColumn(collect=true){
  updateLayout();
  let cursorY=rightRect.y;

  if(womanFont) textFont(womanFont); else textFont('monospace');
  textSize(WOMAN_SIZE); textLeading(WOMAN_SIZE*WOMAN_LINE_H);
  const titleLines = wrapLines(WOMAN_TEXT, rightRect.w*WRAP_WIDTH_RATIO, WOMAN_SIZE);
  cursorY = drawRibbonBlock(titleLines, rightRect.x, cursorY, WOMAN_SIZE, WOMAN_PAD_X, WOMAN_PAD_Y, BOX_FILL, BOX_ALPHA, [255,255,255], collect);
  cursorY += PARA_GAP*1.2;

  if(customFont) textFont(customFont); else textFont('monospace');
  textSize(PARA_SIZE); textLeading(PARA_SIZE*PARA_LINE_H);
  const wrapW = rightRect.w*WRAP_WIDTH_RATIO;
  for(let p=0;p<paragraphs.length;p++){
    const lines = wrapLines(paragraphs[p], wrapW, PARA_SIZE);
    cursorY = drawRibbonBlock(lines, rightRect.x, cursorY, PARA_SIZE, PARA_PAD_X, PARA_PAD_Y, BOX_FILL, BOX_ALPHA, TEXT_COLOR, collect);
    cursorY += PARA_GAP;
  }
}
function drawRibbonBlock(lines,x,y,fontSize,padX,padY,fillRGB,fillAlpha,textRGB,collectEdges){
  const widths=lines.map(s=>max(1,textWidth(s.replace(/\s+$/,''))));
  const boxWs=widths.map(w=>w+padX*2), boxH=fontSize+padY*2;
  drawRibbonShape(x+SHADOW_OFFSET,y+SHADOW_OFFSET,boxWs,boxH,color(0,SHADOW_ALPHA),null);
  drawRibbonShape(x,y,boxWs,boxH,color(fillRGB[0],fillRGB[1],fillRGB[2],fillAlpha),{tear:true});
  fill(textRGB[0],textRGB[1],textRGB[2]); noStroke();
  for(let i=0;i<lines.length;i++){ const s=lines[i].replace(/\s+$/,''); const ty=y+padY+i*boxH; text(s,x+padX,ty); }
  if(collectEdges) collectRibbonBottomEdges(x,y,boxWs,boxH);
  return y+lines.length*boxH;
}
function drawRibbonShape(x,y,boxWs,boxH,fillCol,opt={tear:false}){
  const pts=buildRibbonOutline(x,y,boxWs,boxH);
  noStroke(); fill(fillCol); beginShape(); for(const p of pts) vertex(p.x,p.y); endShape(CLOSE);
  if(opt&&opt.tear){ noFill(); stroke(255,TEAR_ALPHA); strokeWeight(2); beginShape();
    for(const p of pts){ const jx=(noise(p.x*TEAR_SCALE,p.y*TEAR_SCALE)-.5)*2*TEAR_INTENSITY;
      const jy=(noise(p.x*TEAR_SCALE+999,p.y*TEAR_SCALE+999)-.5)*2*TEAR_INTENSITY; vertex(p.x+jx,p.y+jy); }
    endShape(CLOSE);
  }
}
function buildRibbonOutline(x,y,boxWs,boxH){
  const n=boxWs.length, pts=[]; pts.push({x:x,y:y}); pts.push({x:x+boxWs[0],y:y});
  for(let i=0;i<n;i++){ pts.push({x:x+boxWs[i],y:y+(i+1)*boxH}); if(i<n-1) pts.push({x:x+boxWs[i+1],y:y+(i+1)*boxH}); }
  pts.push({x:x,y:y+n*boxH}); pts.push({x:x,y:y}); return pts;
}
function collectRibbonBottomEdges(x,y,boxWs,boxH){
  const n=boxWs.length;
  for(let i=0;i<n-1;i++){ if(boxWs[i]>boxWs[i+1]){ const yEdge=y+(i+1)*boxH, x1=x+boxWs[i+1], x2=x+boxWs[i]; ribbonEdges.push({x1,x2,y:yEdge}); } }
  const yBottom=y+n*boxH; ribbonEdges.push({x1:x,x2:x+boxWs[n-1],y:yBottom});
}

/* 出血 */
function bleedRibbons(){
  if(!ribbonBleedStarted){ if(frameCount-ribbonBleedStart>=RIBBON_BLEED_DELAY_FRAMES) ribbonBleedStarted=true; else return; }
  for(const seg of ribbonEdges){
    const L=max(0,seg.x2-seg.x1); if(L<=0) continue;
    const expected=L*RIBBON_SPAWN_DENSITY, n=floor(expected), prob=expected-n;
    let count=n+(random()<prob?1:0); count=min(count,max(0,RIBBON_DRIP_MAX-ribbonDrips.length));
    for(let k=0;k<count;k++){
      const x=random(seg.x1+.5, seg.x2-.5), y0=seg.y+1, maxLen=max(0,height-y0-6);
      const len=constrain(random(RIBBON_DRIP_LEN_MIN,RIBBON_DRIP_LEN_MAX),12,maxLen);
      ribbonDrips.push({ x,y0, head:0, len, speed:random(RIBBON_DRIP_SPEED_MIN,RIBBON_DRIP_SPEED_MAX),
        thick:random(RIBBON_DRIP_THICK_MIN,RIBBON_DRIP_THICK_MAX), seed:random(1000) });
      if(ribbonDrips.length>=RIBBON_DRIP_MAX) break;
    }
    if(ribbonDrips.length>=RIBBON_DRIP_MAX) break;
  }
  noStroke();
  for(let i=ribbonDrips.length-1;i>=0;i--){
    const d=ribbonDrips[i]; d.speed*=1.01; d.head+=d.speed;
    const segH=3;
    for(let yy=0; yy<d.head && yy<d.len; yy+=segH){
      const t=yy/d.len, w=lerp(d.thick,d.thick*0.65,t);
      const wob=(noise(d.seed+yy*0.05+frameCount*0.02)-.5)*2*RIBBON_DRIP_WOBBLE;
      fill(BOX_FILL[0],BOX_FILL[1],BOX_FILL[2],RIBBON_DRIP_ALPHA); rect(d.x+wob-w/2, d.y0+yy, w, segH);
    }
    const wobHead=(noise(d.seed+d.head*0.05+frameCount*0.02)-.5)*2*RIBBON_DRIP_WOBBLE;
    fill(BOX_FILL[0],BOX_FILL[1],BOX_FILL[2],min(255,RIBBON_DRIP_ALPHA+10)); ellipse(d.x+wobHead, d.y0+d.head, d.thick*1.2, d.thick*1.2);
    if(d.head>d.len) ribbonDrips.splice(i,1);
  }
}

/* 工具 */
function wrapLines(textStr, maxW, fontSize){
  const tokens=textStr.split(/(\s+)/); let lines=['']; textSize(fontSize);
  for(const tk of tokens){ const trial=lines[lines.length-1]+tk;
    if(textWidth(trial)<=maxW || lines[lines.length-1]===''){ lines[lines.length-1]=trial; }
    else { lines.push(tk.trimStart()); } }
  return lines.map(s=>s.replace(/\s+$/,''));
}
function updateLayout(){
  const rightX=floor(width*RIGHT_RATIO)+GUTTER, rightW=max(220,width-rightX-SAFE_RIGHT), rightY=SAFE_TOP, rightH=height-SAFE_TOP-SAFE_BOTTOM;
  rightRect={x:rightX,y:rightY,w:rightW,h:rightH};
}
function keyOutBlack(srcImg, threshold=28, softness=24){
  let keyed=createImage(srcImg.width, srcImg.height);
  keyed.copy(srcImg,0,0,srcImg.width,srcImg.height,0,0,srcImg.width,srcImg.height);
  keyed.loadPixels();
  const n=keyed.width*keyed.height;
  for(let i=0;i<n;i++){
    const idx=i*4, r=keyed.pixels[idx], g=keyed.pixels[idx+1], b=keyed.pixels[idx+2], a0=keyed.pixels[idx+3], bright=(r+g+b)/3;
    if(bright<=threshold) keyed.pixels[idx+3]=0;
    else if(softness>0 && bright<threshold+softness){ const t=(bright-threshold)/softness; keyed.pixels[idx+3]=a0*t; }
  }
  keyed.updatePixels(); return keyed;
}
function windowResized(){
  resizeCanvas(windowWidth, windowHeight);
  mosaicBuffer=createGraphics(width,height); mosaicBuffer.noStroke();
  if(video) video.size(floor(width/RESOLUTION), floor(height/RESOLUTION));
  updateLayout(); initEyes();
}

/* 眼睛层 */
function initEyes(){
  eyes=[]; if(!eyeImg) return;
  for(let i=0;i<EYE_COUNT;i++){
    const margin=40, x=random(margin,width-margin), y=random(margin,height-margin);
    const targetW = random(90,140)*(width/1280 * 0.9 + 0.55);
    const targetH = targetW * (eyeImg.height/eyeImg.width);
    eyes.push({ baseX:x, baseY:y, w:targetW, h:targetH, amp:random(4,10), spd:random(0.015,0.035), phase:random(TWO_PI), rotAmp:random(-0.06,0.06)});
  }
}
function drawEyes(){
  if(!eyeImg || eyes.length===0) return;
  push(); imageMode(CENTER);
  for(const e of eyes){
    const dy=sin(frameCount*e.spd+e.phase)*e.amp, dx=cos(frameCount*e.spd*0.8+e.phase)*e.amp*0.35, rot=sin(frameCount*e.spd*0.6+e.phase)*e.rotAmp;
    push(); translate(e.baseX+dx, e.baseY+dy); rotate(rot); image(eyeImg,0,0,e.w,e.h); pop();
  }
  pop();
}
</script>
</body>
</html>
  B1:'assets/glitch_B1.gif', B2:'assets/glitch_B2.gif', B3:'assets/glitch_B3.gif', B4:'assets/glitch_B4.gif', B5:'assets/glitch_B5.gif', B6:'assets/glitch_B6.gif',
  C1:'assets/glitch_C1.gif'
};

/*==================== 你的视觉（保留 eye 层；glitch 随故事） ====================*/
// 字体 / 资源
let fontPath="fonts.ttf", WOMAN_FONT_PATH="SpecialElite-Regular.ttf";
let USE_GLITCH_IMAGE = true;
let GLITCH_IMAGE_PATH = GLITCH_MAP[storyKey] || 'assets/glitch_default.gif';

// 眼睛层：所有故事统一一张图
let EYE_IMAGE_PATH = 'assets/eyes.png';
let EYE_COUNT = 7;

// 马赛克
let RESOLUTION=10, ASCII_UPDATE_INTERVAL=3, MOSAIC_LEVELS=6, MOSAIC_ALPHA=255, MOSAIC_MIN_GRAY=20, MOSAIC_MAX_GRAY=170, BG_DARKEN_ALPHA=45;

// glitch（闪现）
let GLITCH_IMAGE_ALPHA=245, GLITCH_FLASH_PROB=0.015, GLITCH_MIN_FRAMES=15, GLITCH_MAX_FRAMES=30;
let KEY_OUT_BLACK=true, KEY_BLACK_THRESHOLD=28, KEY_BLACK_SOFTNESS=24;

// 右侧丝带
let RIGHT_RATIO=0.56, SAFE_TOP=30, SAFE_RIGHT=30, SAFE_BOTTOM=30, GUTTER=24;
let WOMAN_TEXT = storyLabel || 'woman', WOMAN_SIZE=96, WOMAN_LINE_H=1.05, WOMAN_PAD_X=14, WOMAN_PAD_Y=8, WOMAN_COLOR=[255,255,255];
let PARA_SIZE=16, PARA_LINE_H=1.25, PARA_PAD_X=12, PARA_PAD_Y=8, PARA_GAP=12, BOX_FILL=[210,20,20], BOX_ALPHA=220, TEXT_COLOR=[255,255,255], SHADOW_ALPHA=40, SHADOW_OFFSET=2;
let TEAR_INTENSITY=2.0, TEAR_SCALE=0.03, TEAR_ALPHA=35, WRAP_WIDTH_RATIO=0.95;

// 出血
let RIBBON_BLEED_ENABLED=true, RIBBON_BLEED_DELAY_FRAMES=200, RIBBON_SPAWN_DENSITY=0.00010, RIBBON_DRIP_MAX=350,
    RIBBON_DRIP_SPEED_MIN=0.05, RIBBON_DRIP_SPEED_MAX=0.2, RIBBON_DRIP_LEN_MIN=80, RIBBON_DRIP_LEN_MAX=380,
    RIBBON_DRIP_THICK_MIN=7, RIBBON_DRIP_THICK_MAX=8, RIBBON_DRIP_WOBBLE=0.85, RIBBON_DRIP_ALPHA=230;

// 运行变量
let customFont, womanFont, video, mosaicBuffer, mosaicTick=0, glitchStill=null, glitchKeyed=null, glitchOn=false, glitchFramesLeft=0;
let rightRect={x:0,y:0,w:0,h:0}, paragraphs=buildStoryParagraphs();
let ribbonEdges=[], ribbonDrips=[], ribbonBleedStart=0, ribbonBleedStarted=false;
// eye 层
let eyeImg=null, eyes=[];

// 预加载
function preload(){
  try{ customFont=loadFont(fontPath);}catch(e){}
  try{ womanFont=loadFont(WOMAN_FONT_PATH);}catch(e){}
  if(USE_GLITCH_IMAGE) glitchStill = loadImage(GLITCH_IMAGE_PATH);
  eyeImg = loadImage(EYE_IMAGE_PATH, ()=>{}, ()=>{ eyeImg=null; });
}

// 初始化
function setup(){
  createCanvas(windowWidth, windowHeight);
  if(customFont) textFont(customFont); textAlign(LEFT,TOP);
  video = createCapture(VIDEO); video.size(floor(width/RESOLUTION), floor(height/RESOLUTION)); video.hide();
  mosaicBuffer = createGraphics(width,height); mosaicBuffer.noStroke();
  if(USE_GLITCH_IMAGE && KEY_OUT_BLACK && glitchStill){ glitchKeyed = keyOutBlack(glitchStill, KEY_BLACK_THRESHOLD, KEY_BLACK_SOFTNESS); }
  updateLayout(); ribbonBleedStart=frameCount; initEyes();
}

// 每帧
function draw(){
  background(0);
  drawMosaicBackground();
  if(BG_DARKEN_ALPHA>0){ noStroke(); fill(0,BG_DARKEN_ALPHA); rect(0,0,width,height); }

  // 眼睛层（在 glitch 与文字之下；glitch 出现时不画眼睛）
  if(!glitchOn) drawEyes();

  // glitch（随故事挑素材）
  maybeFlashGlitchImage();

  // 丝带与出血
  ribbonEdges.length=0; drawRightColumn(true);
  if(RIBBON_BLEED_ENABLED) bleedRibbons();
  drawRightColumn(false);
}

/* === 背景马赛克 === */
function drawMosaicBackground(){
  if(mosaicTick % ASCII_UPDATE_INTERVAL === 0){
    mosaicBuffer.clear(); video.loadPixels();
    for(let y=0;y<video.height;y++){
      for(let x=0;x<video.width;x++){
        const idx=(x+y*video.width)*4;
        const r=video.pixels[idx], g=video.pixels[idx+1], b=video.pixels[idx+2];
        const bright=(r+g+b)/3;
        const level=floor(map(bright,0,255,0,MOSAIC_LEVELS));
        const q=map(level,0,MOSAIC_LEVELS-1,MOSAIC_MIN_GRAY,MOSAIC_MAX_GRAY);
        mosaicBuffer.fill(q,MOSAIC_ALPHA);
        mosaicBuffer.rect(x*RESOLUTION,y*RESOLUTION,RESOLUTION,RESOLUTION);
      }
    }
  }
  mosaicTick++; image(mosaicBuffer,0,0);
}

/* === glitch 闪现（抠黑） === */
function maybeFlashGlitchImage(){
  if(!USE_GLITCH_IMAGE || !glitchStill) return;
  if(!glitchOn && random()<GLITCH_FLASH_PROB){ glitchOn=true; glitchFramesLeft=floor(random(GLITCH_MIN_FRAMES,GLITCH_MAX_FRAMES+1)); }
  if(glitchOn){
    push(); tint(255,GLITCH_IMAGE_ALPHA); const img=(KEY_OUT_BLACK && glitchKeyed)?glitchKeyed:glitchStill;
    const cs=min(width,height), is=min(img.width,img.height), sc=cs/is, dw=img.width*sc, dh=img.height*sc, dx=(width-dw)/2, dy=(height-dh)/2;
    image(img,dx,dy,dw,dh); pop();
    if(--glitchFramesLeft<=0) glitchOn=false;
  }
}

/* === 右侧丝带 === */
function drawRightColumn(collect=true){
  updateLayout();
  let cursorY=rightRect.y;

  if(womanFont) textFont(womanFont); else textFont('monospace');
  textSize(WOMAN_SIZE); textLeading(WOMAN_SIZE*WOMAN_LINE_H);
  const titleLines = wrapLines(WOMAN_TEXT, rightRect.w*WRAP_WIDTH_RATIO, WOMAN_SIZE);
  cursorY = drawRibbonBlock(titleLines, rightRect.x, cursorY, WOMAN_SIZE, WOMAN_PAD_X, WOMAN_PAD_Y, BOX_FILL, BOX_ALPHA, [255,255,255], collect);
  cursorY += PARA_GAP*1.2;

  if(customFont) textFont(customFont); else textFont('monospace');
  textSize(PARA_SIZE); textLeading(PARA_SIZE*PARA_LINE_H);
  const wrapW = rightRect.w*WRAP_WIDTH_RATIO;
  for(let p=0;p<paragraphs.length;p++){
    const lines = wrapLines(paragraphs[p], wrapW, PARA_SIZE);
    cursorY = drawRibbonBlock(lines, rightRect.x, cursorY, PARA_SIZE, PARA_PAD_X, PARA_PAD_Y, BOX_FILL, BOX_ALPHA, TEXT_COLOR, collect);
    cursorY += PARA_GAP;
  }
}
function drawRibbonBlock(lines,x,y,fontSize,padX,padY,fillRGB,fillAlpha,textRGB,collectEdges){
  const widths=lines.map(s=>max(1,textWidth(s.replace(/\s+$/,''))));
  const boxWs=widths.map(w=>w+padX*2), boxH=fontSize+padY*2;
  drawRibbonShape(x+SHADOW_OFFSET,y+SHADOW_OFFSET,boxWs,boxH,color(0,SHADOW_ALPHA),null);
  drawRibbonShape(x,y,boxWs,boxH,color(fillRGB[0],fillRGB[1],fillRGB[2],fillAlpha),{tear:true});
  fill(textRGB[0],textRGB[1],textRGB[2]); noStroke();
  for(let i=0;i<lines.length;i++){ const s=lines[i].replace(/\s+$/,''); const ty=y+padY+i*boxH; text(s,x+padX,ty); }
  if(collectEdges) collectRibbonBottomEdges(x,y,boxWs,boxH);
  return y+lines.length*boxH;
}
function drawRibbonShape(x,y,boxWs,boxH,fillCol,opt={tear:false}){
  const pts=buildRibbonOutline(x,y,boxWs,boxH);
  noStroke(); fill(fillCol); beginShape(); for(const p of pts) vertex(p.x,p.y); endShape(CLOSE);
  if(opt&&opt.tear){ noFill(); stroke(255,TEAR_ALPHA); strokeWeight(2); beginShape();
    for(const p of pts){ const jx=(noise(p.x*TEAR_SCALE,p.y*TEAR_SCALE)-.5)*2*TEAR_INTENSITY;
      const jy=(noise(p.x*TEAR_SCALE+999,p.y*TEAR_SCALE+999)-.5)*2*TEAR_INTENSITY; vertex(p.x+jx,p.y+jy); }
    endShape(CLOSE);
  }
}
function buildRibbonOutline(x,y,boxWs,boxH){
  const n=boxWs.length, pts=[]; pts.push({x:x,y:y}); pts.push({x:x+boxWs[0],y:y});
  for(let i=0;i<n;i++){ pts.push({x:x+boxWs[i],y:y+(i+1)*boxH}); if(i<n-1) pts.push({x:x+boxWs[i+1],y:y+(i+1)*boxH}); }
  pts.push({x:x,y:y+n*boxH}); pts.push({x:x,y:y}); return pts;
}
function collectRibbonBottomEdges(x,y,boxWs,boxH){
  const n=boxWs.length;
  for(let i=0;i<n-1;i++){ if(boxWs[i]>boxWs[i+1]){ const yEdge=y+(i+1)*boxH, x1=x+boxWs[i+1], x2=x+boxWs[i]; ribbonEdges.push({x1,x2,y:yEdge}); } }
  const yBottom=y+n*boxH; ribbonEdges.push({x1:x,x2:x+boxWs[n-1],y:yBottom});
}

/* === 出血 === */
function bleedRibbons(){
  if(!ribbonBleedStarted){ if(frameCount-ribbonBleedStart>=RIBBON_BLEED_DELAY_FRAMES) ribbonBleedStarted=true; else return; }
  for(const seg of ribbonEdges){
    const L=max(0,seg.x2-seg.x1); if(L<=0) continue;
    const expected=L*RIBBON_SPAWN_DENSITY, n=floor(expected), prob=expected-n;
    let count=n+(random()<prob?1:0); count=min(count,max(0,RIBBON_DRIP_MAX-ribbonDrips.length));
    for(let k=0;k<count;k++){
      const x=random(seg.x1+.5, seg.x2-.5), y0=seg.y+1, maxLen=max(0,height-y0-6);
      const len=constrain(random(RIBBON_DRIP_LEN_MIN,RIBBON_DRIP_LEN_MAX),12,maxLen);
      ribbonDrips.push({ x,y0, head:0, len, speed:random(RIBBON_DRIP_SPEED_MIN,RIBBON_DRIP_SPEED_MAX),
        thick:random(RIBBON_DRIP_THICK_MIN,RIBBON_DRIP_THICK_MAX), seed:random(1000) });
      if(ribbonDrips.length>=RIBBON_DRIP_MAX) break;
    }
    if(ribbonDrips.length>=RIBBON_DRIP_MAX) break;
  }
  noStroke();
  for(let i=ribbonDrips.length-1;i>=0;i--){
    const d=ribbonDrips[i]; d.speed*=1.01; d.head+=d.speed;
    const segH=3;
    for(let yy=0; yy<d.head && yy<d.len; yy+=segH){
      const t=yy/d.len, w=lerp(d.thick,d.thick*0.65,t);
      const wob=(noise(d.seed+yy*0.05+frameCount*0.02)-.5)*2*RIBBON_DRIP_WOBBLE;
      fill(BOX_FILL[0],BOX_FILL[1],BOX_FILL[2],RIBBON_DRIP_ALPHA); rect(d.x+wob-w/2, d.y0+yy, w, segH);
    }
    const wobHead=(noise(d.seed+d.head*0.05+frameCount*0.02)-.5)*2*RIBBON_DRIP_WOBBLE;
    fill(BOX_FILL[0],BOX_FILL[1],BOX_FILL[2],min(255,RIBBON_DRIP_ALPHA+10)); ellipse(d.x+wobHead, d.y0+d.head, d.thick*1.2, d.thick*1.2);
    if(d.head>d.len) ribbonDrips.splice(i,1);
  }
}

/* === 眼睛层（所有故事统一素材） === */
function initEyes(){
  eyes=[]; if(!eyeImg) return;
  for(let i=0;i<EYE_COUNT;i++){
    const margin=40, x=random(margin,width-margin), y=random(margin,height-margin);
    const targetW = random(90,140)*(width/1280 * 0.9 + 0.55);
    const targetH = targetW * (eyeImg.height/eyeImg.width);
    eyes.push({ baseX:x, baseY:y, w:targetW, h:targetH, amp:random(4,10), spd:random(0.015,0.035), phase:random(TWO_PI), rotAmp:random(-0.06,0.06)});
  }
}
function drawEyes(){
  if(!eyeImg || eyes.length===0) return;
  push(); imageMode(CENTER);
  for(const e of eyes){
    const dy=sin(frameCount*e.spd+e.phase)*e.amp, dx=cos(frameCount*e.spd*0.8+e.phase)*e.amp*0.35, rot=sin(frameCount*e.spd*0.6+e.phase)*e.rotAmp;
    push(); translate(e.baseX+dx, e.baseY+dy); rotate(rot); image(eyeImg,0,0,e.w,e.h); pop();
  }
  pop();
}

/* === 工具 === */
function wrapLines(textStr, maxW, fontSize){
  const tokens=textStr.split(/(\\s+)/); let lines=['']; textSize(fontSize);
  for(const tk of tokens){ const trial=lines[lines.length-1]+tk;
    if(textWidth(trial)<=maxW || lines[lines.length-1]===''){ lines[lines.length-1]=trial; }
    else { lines.push(tk.trimStart()); } }
  return lines.map(s=>s.replace(/\\s+$/,''));
}
function updateLayout(){
  const rightX=floor(width*RIGHT_RATIO)+GUTTER, rightW=max(220,width-rightX-SAFE_RIGHT), rightY=SAFE_TOP, rightH=height-SAFE_TOP-SAFE_BOTTOM;
  rightRect={x:rightX,y:rightY,w:rightW,h:rightH};
}
function keyOutBlack(srcImg, threshold=28, softness=24){
  let keyed=createImage(srcImg.width, srcImg.height);
  keyed.copy(srcImg,0,0,srcImg.width,srcImg.height,0,0,srcImg.width,srcImg.height);
  keyed.loadPixels();
  const n=keyed.width*keyed.height;
  for(let i=0;i<n;i++){
    const idx=i*4, r=keyed.pixels[idx], g=keyed.pixels[idx+1], b=keyed.pixels[idx+2], a0=keyed.pixels[idx+3], bright=(r+g+b)/3;
    if(bright<=threshold) keyed.pixels[idx+3]=0;
    else if(softness>0 && bright<threshold+softness){ const t=(bright-threshold)/softness; keyed.pixels[idx+3]=a0*t; }
  }
  keyed.updatePixels(); return keyed;
}
function windowResized(){
  resizeCanvas(windowWidth, windowHeight);
  mosaicBuffer=createGraphics(width,height); mosaicBuffer.noStroke();
  if(video) video.size(floor(width/RESOLUTION), floor(height/RESOLUTION));
  updateLayout(); initEyes();
}
</script>
</body>
</html>
}

/*********************** 15 张故障图与故事键映射 ***********************/
// 请把对应文件放在 /assets/ 目录下；后缀可用 .gif/.png/.webp
// 你也可以改成完全不同的文件名，只要改这个映射表即可。
const GLITCH_MAP = {
  A1:'assets/glitch_A1.gif', A2:'assets/glitch_A2.gif', A3:'assets/glitch_A3.gif', A4:'assets/glitch_A4.gif', A5:'assets/glitch_A5.gif', A6:'assets/glitch_A6.gif',
  B1:'assets/glitch_B1.gif', B2:'assets/glitch_B2.gif', B3:'assets/glitch_B3.gif', B4:'assets/glitch_B4.gif', B5:'assets/glitch_B5.gif', B6:'assets/glitch_B6.gif',
  C1:'assets/glitch_C1.gif'
};

/*********************** ↓↓↓ 下面是你给的视觉（做了两点改动） ↓↓↓ ***********************/
// 改动 1：不再使用“小眼睛”图层（已完全移除）
// 改动 2：GLITCH_IMAGE_PATH 由上面的 GLITCH_MAP[storyKey] 决定

// ---------------- 字体 / 资源 ----------------
let fontPath = "fonts.ttf";               // 可选：如无字体文件会回退系统等宽
let WOMAN_FONT_PATH = "SpecialElite-Regular.ttf"; // 可选
let USE_GLITCH_IMAGE = true;
let GLITCH_IMAGE_PATH = GLITCH_MAP[storyKey] || 'assets/glitch_default.gif'; // ← 与故事键对应

// ★ 眼睛层：所有故事统一一张图（不会随故事变化）
let EYE_IMAGE_PATH = 'assets/eyes.png'; // ← 放一张你的小眼睛图；所有故事通用
let EYE_COUNT = 7;                      // 眼睛数量（可调）

// ---------------- 马赛克灰块底图（更暗控制） ----------------
let RESOLUTION = 10;
let ASCII_UPDATE_INTERVAL = 3;
let MOSAIC_LEVELS = 6;
let MOSAIC_ALPHA = 255;
let MOSAIC_MIN_GRAY = 20;
let MOSAIC_MAX_GRAY = 170;
let BG_DARKEN_ALPHA = 45;

// ---------------- glitch（随机闪现 + 抠黑） ----------------
let GLITCH_IMAGE_ALPHA = 245;
let GLITCH_FLASH_PROB = 0.015;
let GLITCH_MIN_FRAMES = 15;
let GLITCH_MAX_FRAMES = 30;
let KEY_OUT_BLACK = true;
let KEY_BLACK_THRESHOLD = 28;
let KEY_BLACK_SOFTNESS  = 24;

// ---------------- 右侧排版（红色丝带） ----------------
let RIGHT_RATIO = 0.56;
let SAFE_TOP = 30, SAFE_RIGHT = 30, SAFE_BOTTOM = 30, GUTTER = 24;

let WOMAN_TEXT = storyLabel || 'woman';
let WOMAN_SIZE = 96;
let WOMAN_LINE_H = 1.05;
let WOMAN_PAD_X = 14, WOMAN_PAD_Y = 8;
let WOMAN_COLOR = [255,255,255];

let PARA_SIZE = 16;
let PARA_LINE_H = 1.25;
let PARA_PAD_X = 12, PARA_PAD_Y = 8;
let PARA_GAP = 12;
let BOX_FILL = [210, 20, 20];
let BOX_ALPHA = 220;
let TEXT_COLOR = [255,255,255];
let SHADOW_ALPHA = 40;
let SHADOW_OFFSET = 2;

let TEAR_INTENSITY = 2.0;
let TEAR_SCALE = 0.03;
let TEAR_ALPHA = 35;

let WRAP_WIDTH_RATIO = 0.95;

// ---------------- 丝带出血（全栏）旋钮（慢/粗/少） ----------------
let RIBBON_BLEED_ENABLED    = true;
let RIBBON_BLEED_DELAY_FRAMES = 200;
let RIBBON_SPAWN_DENSITY    = 0.00010;
let RIBBON_DRIP_MAX         = 350;
let RIBBON_DRIP_SPEED_MIN   = 0.05;
let RIBBON_DRIP_SPEED_MAX   = 0.2;
let RIBBON_DRIP_LEN_MIN     = 80;
let RIBBON_DRIP_LEN_MAX     = 380;
let RIBBON_DRIP_THICK_MIN   = 7;
let RIBBON_DRIP_THICK_MAX   = 8;
let RIBBON_DRIP_WOBBLE      = 0.85;
let RIBBON_DRIP_ALPHA       = 230;

// ---------------- 文案（由模板生成） ----------------
let paragraphs = buildStoryText();

// ---------------- 运行变量 ----------------
let customFont, womanFont;
let video, mosaicBuffer, mosaicTick = 0;
let glitchStill = null, glitchKeyed = null, glitchOn = false, glitchFramesLeft = 0;
let rightRect = {x:0,y:0,w:0,h:0};

// ★ 眼睛层变量
let eyeImg = null;
let eyes = []; // {baseX,baseY,w,h,amp,spd,phase,rotAmp}

// 丝带出血：边缘与滴 + 分层重绘
let ribbonEdges = [];
let ribbonDrips = [];
let ribbonBleedStart = 0;
let ribbonBleedStarted = false;

// ---------- 预加载 ----------
function preload() {
  // 可选字体（找不到会自动回退）
  try { customFont = loadFont(fontPath); } catch(e) {}
  try { womanFont  = loadFont(WOMAN_FONT_PATH); } catch(e) {}
  if (USE_GLITCH_IMAGE) glitchStill = loadImage(GLITCH_IMAGE_PATH);
  // ★ 统一的眼睛素材（不随故事变化）
  eyeImg = loadImage(EYE_IMAGE_PATH, ()=>{}, ()=>{ eyeImg=null; });
} catch(e) {}
  try { womanFont  = loadFont(WOMAN_FONT_PATH); } catch(e) {}
  if (USE_GLITCH_IMAGE) glitchStill = loadImage(GLITCH_IMAGE_PATH);
}

// ---------- 初始化 ----------
function setup() {
  createCanvas(windowWidth, windowHeight);
  if (customFont) textFont(customFont);
  textAlign(LEFT, TOP);

  video = createCapture(VIDEO);
  video.size(floor(width / RESOLUTION), floor(height / RESOLUTION));
  video.hide();

  mosaicBuffer = createGraphics(width, height);
  mosaicBuffer.noStroke();

  if (USE_GLITCH_IMAGE && KEY_OUT_BLACK && glitchStill) {
    glitchKeyed = keyOutBlack(glitchStill, KEY_BLACK_THRESHOLD, KEY_BLACK_SOFTNESS);
  }

  updateLayout();
  ribbonBleedStart = frameCount;

  initEyes(); // ★ 初始化小眼睛
}

// ---------- 每帧 ----------
function draw() {
  background(0);

  // 1) 底图（马赛克）
  drawMosaicBackground();

  // 2) 背景加深罩
  if (BG_DARKEN_ALPHA > 0) {
    noStroke();
    fill(0, BG_DARKEN_ALPHA);
    rect(0, 0, width, height);
  }

  // 3) 小眼睛（在 glitch 之下、文字之下；与原版一致：glitch 出现时不绘制眼睛）
  if (!glitchOn) drawEyes();

  // 4) glitch（与你原版一样：随机闪现一张素材图，按短边等比 + 抠黑）
  maybeFlashGlitchImage();

  // 5) 先画红丝带（收集外露边缘）
  ribbonEdges.length = 0;
  drawRightColumn(true);

  // 6) 画滴血（会出现在丝带外侧）
  if (RIBBON_BLEED_ENABLED) bleedRibbons();

  // 7) 再把丝带+文字“罩一层”作为遮罩，保证不挡字
  drawRightColumn(false);
}

/* ====================== 底图：马赛克灰块（更暗） ====================== */
function drawMosaicBackground() {
  if (mosaicTick % ASCII_UPDATE_INTERVAL === 0) {
    mosaicBuffer.clear();
    video.loadPixels();

    for (let y = 0; y < video.height; y++) {
      for (let x = 0; x < video.width; x++) {
        const idx = (x + y * video.width) * 4;
        const r = video.pixels[idx + 0];
        const g = video.pixels[idx + 1];
        const b = video.pixels[idx + 2];
        const bright = (r + g + b) / 3;

        const level = floor(map(bright, 0, 255, 0, MOSAIC_LEVELS));
        const q = map(level, 0, MOSAIC_LEVELS - 1, MOSAIC_MIN_GRAY, MOSAIC_MAX_GRAY);
        mosaicBuffer.fill(q, MOSAIC_ALPHA);
        mosaicBuffer.rect(x * RESOLUTION, y * RESOLUTION, RESOLUTION, RESOLUTION);
      }
    }
  }
  mosaicTick++;
  image(mosaicBuffer, 0, 0);
}

/* ====================== glitch：按短边等比 + 抠黑 ====================== */
function maybeFlashGlitchImage() {
  if (!USE_GLITCH_IMAGE || !glitchStill) return;

  // 触发一次闪现（与你原逻辑一致）
  if (!glitchOn && random() < GLITCH_FLASH_PROB) {
    glitchOn = true;
    glitchFramesLeft = floor(random(GLITCH_MIN_FRAMES, GLITCH_MAX_FRAMES + 1));
  }

  if (glitchOn) {
    push();
    tint(255, GLITCH_IMAGE_ALPHA);
    const img = (KEY_OUT_BLACK && glitchKeyed) ? glitchKeyed : glitchStill;

    const canvasShort = min(width, height);
    const imgShort = min(img.width, img.height);
    const scale = canvasShort / imgShort;
    const drawW = img.width * scale;
    const drawH = img.height * scale;
    const dx = (width  - drawW) / 2;
    const dy = (height - drawH) / 2;

    image(img, dx, dy, drawW, drawH);
    pop();

    glitchFramesLeft--;
    if (glitchFramesLeft <= 0) {
      glitchOn = false;
    }
  }
}

/* ====================== 右侧：红丝带（连成一条 + 撕纸毛边） ====================== */
function drawRightColumn(collect = true) {
  updateLayout();

  let cursorY = rightRect.y;

  // WOMAN/TITLE（这里用 storyLabel）
  if (womanFont) textFont(womanFont); else textFont("monospace");
  textSize(WOMAN_SIZE);
  textLeading(WOMAN_SIZE * WOMAN_LINE_H);

  const womanWrapW = rightRect.w * WRAP_WIDTH_RATIO;
  const womanLines = wrapLines(WOMAN_TEXT, womanWrapW, WOMAN_SIZE);
  cursorY = drawRibbonBlock(
    womanLines,
    rightRect.x, cursorY,
    WOMAN_SIZE, WOMAN_PAD_X, WOMAN_PAD_Y,
    BOX_FILL, BOX_ALPHA,
    WOMAN_COLOR,
    collect
  );
  cursorY += PARA_GAP * 1.2;

  // 段落（由模板生成的 paragraphs）
  if (customFont) textFont(customFont); else textFont("monospace");
  textSize(PARA_SIZE);
  textLeading(PARA_SIZE * PARA_LINE_H);

  const paraWrapW = rightRect.w * WRAP_WIDTH_RATIO;
  for (let p = 0; p < paragraphs.length; p++) {
    const lines = wrapLines(paragraphs[p], paraWrapW, PARA_SIZE);
    cursorY = drawRibbonBlock(
      lines,
      rightRect.x, cursorY,
      PARA_SIZE, PARA_PAD_X, PARA_PAD_Y,
      BOX_FILL, BOX_ALPHA,
      TEXT_COLOR,
      collect
    );
    cursorY += PARA_GAP;
  }
}

function drawRibbonBlock(lines, x, y, fontSize, padX, padY, fillRGB, fillAlpha, textRGB, collectEdges) {
  const widths = lines.map(s => max(1, textWidth(s.replace(/\s+$/,""))));
  const boxWs = widths.map(w => w + padX * 2);
  const boxH  = fontSize + padY * 2;

  // 阴影
  drawRibbonShape(x + SHADOW_OFFSET, y + SHADOW_OFFSET, boxWs, boxH, color(0, SHADOW_ALPHA), null);

  // 主体丝带
  drawRibbonShape(x, y, boxWs, boxH, color(fillRGB[0], fillRGB[1], fillRGB[2], fillAlpha), {tear:true});

  // 白字
  fill(textRGB[0], textRGB[1], textRGB[2]);
  noStroke();
  for (let i = 0; i < lines.length; i++) {
    const s = lines[i].replace(/\s+$/,"");
    const ty = y + padY + i * boxH;
    text(s, x + padX, ty);
  }

  if (collectEdges) collectRibbonBottomEdges(x, y, boxWs, boxH);

  return y + lines.length * boxH;
}

function drawRibbonShape(x, y, boxWs, boxH, fillCol, opt={tear:false}) {
  const pts = buildRibbonOutline(x, y, boxWs, boxH);

  noStroke();
  fill(fillCol);
  beginShape();
  for (const p of pts) vertex(p.x, p.y);
  endShape(CLOSE);

  if (opt && opt.tear) {
    noFill();
    stroke(255, TEAR_ALPHA);
    strokeWeight(2);
    beginShape();
    for (const p of pts) {
      const jx = (noise(p.x * TEAR_SCALE, p.y * TEAR_SCALE) - 0.5) * 2 * TEAR_INTENSITY;
      const jy = (noise(p.x * TEAR_SCALE + 999, p.y * TEAR_SCALE + 999) - 0.5) * 2 * TEAR_INTENSITY;
      vertex(p.x + jx, p.y + jy);
    }
    endShape(CLOSE);
  }
}

function buildRibbonOutline(x, y, boxWs, boxH) {
  const n = boxWs.length;
  const pts = [];
  pts.push({x: x, y: y});
  pts.push({x: x + boxWs[0], y: y});
  for (let i = 0; i < n; i++) {
    pts.push({x: x + boxWs[i], y: y + (i + 1) * boxH});
    if (i < n - 1) pts.push({x: x + boxWs[i + 1], y: y + (i + 1) * boxH});
  }
  pts.push({x: x, y: y + n * boxH});
  pts.push({x: x, y: y});
  return pts;
}

function collectRibbonBottomEdges(x, y, boxWs, boxH) {
  const n = boxWs.length;
  for (let i = 0; i < n - 1; i++) {
    if (boxWs[i] > boxWs[i + 1]) {
      const yEdge = y + (i + 1) * boxH;
      const x1 = x + boxWs[i + 1];
      const x2 = x + boxWs[i];
      ribbonEdges.push({x1, x2, y: yEdge});
    }
  }
  const yBottom = y + n * boxH;
  ribbonEdges.push({x1: x, x2: x + boxWs[n - 1], y: yBottom});
}

/* ====================== 丝带出血 ====================== */
function bleedRibbons() {
  if (!ribbonBleedStarted) {
    if (frameCount - ribbonBleedStart >= RIBBON_BLEED_DELAY_FRAMES) ribbonBleedStarted = true;
    else return;
  }

  for (const seg of ribbonEdges) {
    const L = max(0, seg.x2 - seg.x1);
    if (L <= 0) continue;

    const expected = L * RIBBON_SPAWN_DENSITY;
    const n = floor(expected);
    const probExtra = expected - n;
    let count = n + (random() < probExtra ? 1 : 0);
    count = min(count, max(0, RIBBON_DRIP_MAX - ribbonDrips.length));

    for (let k = 0; k < count; k++) {
      const x = random(seg.x1 + 0.5, seg.x2 - 0.5);
      const y0 = seg.y + 1;
      const maxLen = max(0, height - y0 - 6);
      const len = constrain(random(RIBBON_DRIP_LEN_MIN, RIBBON_DRIP_LEN_MAX), 12, maxLen);

      ribbonDrips.push({
        x, y0,
        head: 0,
        len,
        speed: random(RIBBON_DRIP_SPEED_MIN, RIBBON_DRIP_SPEED_MAX),
        thick: random(RIBBON_DRIP_THICK_MIN, RIBBON_DRIP_THICK_MAX),
        seed: random(1000)
      });
      if (ribbonDrips.length >= RIBBON_DRIP_MAX) break;
    }
    if (ribbonDrips.length >= RIBBON_DRIP_MAX) break;
  }

  noStroke();
  for (let i = ribbonDrips.length - 1; i >= 0; i--) {
    const d = ribbonDrips[i];
    d.speed *= 1.01;
    d.head  += d.speed;

    const segH = 3;
    for (let yy = 0; yy < d.head && yy < d.len; yy += segH) {
      const t = yy / d.len;
      const w = lerp(d.thick, d.thick * 0.65, t);
      const wob = (noise(d.seed + yy*0.05 + frameCount*0.02) - 0.5) * 2 * RIBBON_DRIP_WOBBLE;
      fill(BOX_FILL[0], BOX_FILL[1], BOX_FILL[2], RIBBON_DRIP_ALPHA);
      rect(d.x + wob - w/2, d.y0 + yy, w, segH);
    }
    const wobHead = (noise(d.seed + d.head*0.05 + frameCount*0.02) - 0.5) * 2 * RIBBON_DRIP_WOBBLE;
    fill(BOX_FILL[0], BOX_FILL[1], BOX_FILL[2], min(255, RIBBON_DRIP_ALPHA + 10));
    ellipse(d.x + wobHead, d.y0 + d.head, d.thick * 1.2, d.thick * 1.2);

    if (d.head > d.len) ribbonDrips.splice(i, 1);
  }
}

/* ====================== 文本换行 ====================== */
function wrapLines(textStr, maxW, fontSize) {
  const tokens = textStr.split(/(\s+)/);
  let lines = [""];
  textSize(fontSize);
  for (const tk of tokens) {
    const trial = lines[lines.length - 1] + tk;
    if (textWidth(trial) <= maxW || lines[lines.length - 1] === "") {
      lines[lines.length - 1] = trial;
    } else {
      lines.push(tk.trimStart());
    }
  }
  return lines.map(s => s.replace(/\s+$/,""));
}

/* ====================== 布局计算 ====================== */
function updateLayout() {
  const rightX = floor(width * RIGHT_RATIO) + GUTTER;
  const rightW = max(220, width - rightX - SAFE_RIGHT);
  const rightY = SAFE_TOP;
  const rightH = height - SAFE_TOP - SAFE_BOTTOM;
  rightRect = {x:rightX, y:rightY, w:rightW, h:rightH};
}

/* ====================== 抠黑工具 ====================== */
function keyOutBlack(srcImg, threshold=28, softness=24) {
  let keyed = createImage(srcImg.width, srcImg.height);
  keyed.copy(srcImg, 0, 0, srcImg.width, srcImg.height, 0, 0, srcImg.width, srcImg.height);
  keyed.loadPixels();
  const n = keyed.width * keyed.height;
  for (let i = 0; i < n; i++) {
    const idx = i * 4;
    const r = keyed.pixels[idx + 0];
    const g = keyed.pixels[idx + 1];
    const b = keyed.pixels[idx + 2];
    const a0 = keyed.pixels[idx + 3];
    const bright = (r + g + b) / 3;

    if (bright <= threshold) {
      keyed.pixels[idx + 3] = 0;
    } else if (softness > 0 && bright < threshold + softness) {
      const t = (bright - threshold) / softness;
      keyed.pixels[idx + 3] = a0 * t;
    }
  }
  keyed.updatePixels();
  return keyed;
}

/* ====================== 自适应窗口 ====================== */
function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  mosaicBuffer = createGraphics(width, height);
  mosaicBuffer.noStroke();
  if (video) video.size(floor(width / RESOLUTION), floor(height / RESOLUTION));
  updateLayout();
  initEyes(); // ★ 重新分布小眼睛
}

/* ====================== ★ 小眼睛：初始化 & 绘制 ====================== */
function initEyes(){
  eyes = [];
  if (!eyeImg) return;
  for (let i = 0; i < EYE_COUNT; i++){
    const margin = 40;
    const x = random(margin, width - margin);
    const y = random(margin, height - margin);
    const targetW = random(90, 140) * (width / 1280 * 0.9 + 0.55);
    const targetH = targetW * (eyeImg ? eyeImg.height/eyeImg.width : 1);
    eyes.push({ baseX:x, baseY:y, w:targetW, h:targetH, amp:random(4,10), spd:random(0.015,0.035), phase:random(TWO_PI), rotAmp:random(-0.06,0.06) });
  }
}
function drawEyes(){
  if (!eyeImg || eyes.length===0) return;
  push(); imageMode(CENTER);
  for (const e of eyes){
    const dy = sin(frameCount*e.spd + e.phase) * e.amp;
    const dx = cos(frameCount*e.spd*0.8 + e.phase) * e.amp * 0.35;
    const rot = sin(frameCount*e.spd*0.6 + e.phase) * e.rotAmp;
    push(); translate(e.baseX + dx, e.baseY + dy); rotate(rot); image(eyeImg, 0, 0, e.w, e.h); pop();
  }
  pop();
}
  const GLITCH = { AMP: 36, SLICES: 36, BLOCKS: 18, SCAN_GAP: 4, SCAN_ALPHA: 80, CHROMA: 110 };
  let video, pg; let camReady=false;

  function setup(){
    const holder = document.getElementById('sketch-holder');
    const c = createCanvas(window.innerWidth, window.innerHeight); c.parent(holder); pixelDensity(1);
    pg = createGraphics(width, height);
    // 摄像头；若用户拒绝权限，降级为渐变背景
    try{
      video = createCapture({video:true, audio:false}, ()=>{ camReady=true; });
      video.size(640,480); video.hide();
    }catch(e){ camReady=false; }
  }
  function windowResized(){ resizeCanvas(window.innerWidth, window.innerHeight); pg=createGraphics(width,height); }

  function draw(){
    if(camReady && video){
      // 画到离屏 pg（镜像 + cover）
      pg.push(); pg.clear(); pg.translate(pg.width,0); pg.scale(-1,1);
      const w=pg.width,h=pg.height,vw=video.width,vh=video.height; const s=max(w/vw,h/vh); const dw=vw*s, dh=vh*s; pg.image(video,(w-dw)/2,(h-dh)/2,dw,dh); pg.pop();
      applyGlitch(pg, GLITCH);
      image(pg,0,0,width,height);
      rgbOffset(pg, GLITCH.CHROMA, GLITCH.AMP);
    }else{
      // 降级静态背景
      const g = drawingContext.createLinearGradient(0,0,width,height); g.addColorStop(0,'#0b0b0b'); g.addColorStop(1,'#1a0c0c'); drawingContext.fillStyle=g; noStroke(); rect(0,0,width,height);
      noFill(); stroke(255,12); for(let i=0;i<height;i+=22) line(0,i,width,i);
    }
  }
  function applyGlitch(g, P){
    const t = millis()*0.001;
    for(let i=0;i<P.SLICES;i++){
      const sh=int(random(6,24)), y=int(random(0,g.height-sh));
      const dx=int(map(noise(t*3+i*.17),0,1,-P.AMP,P.AMP));
      g.copy(g,0,y,g.width,sh, dx,y,g.width,sh);
    }
    for(let i=0;i<P.BLOCKS;i++){
      const bw=int(random(40,160)), bh=int(random(14,60));
      const sx=int(random(0,g.width-bw)), sy=int(random(0,g.height-bh));
      const dx=int(sx + map(noise(t*2.4+i*.31),0,1,-P.AMP,P.AMP));
      const dy=int(sy + map(noise(t*2.7+i*.37),0,1,-P.AMP*.6,P.AMP*.6));
      g.copy(g,sx,sy,bw,bh, dx,dy,bw,bh);
    }
    g.noStroke(); g.fill(255,P.SCAN_ALPHA); const gap=P.SCAN_GAP; const off=int((sin(t*5.2)*.5+.5)*gap);
    for(let y=off; y<g.height; y+=gap){ if(y%(gap*2)===0) g.rect(0,y,g.width,2); }
  }
  function rgbOffset(src, alpha, amp){
    const off=int(map(noise(millis()*0.004),0,1,-amp/2.5, amp/2.5));
    blendMode(ADD); tint(255,60,60,alpha); image(src, off,0);
                   tint(60,255,60,alpha); image(src,-off,0);
                   tint(60,60,255,alpha); image(src, 0,off/2);
    noTint(); blendMode(BLEND);
  }
  </script>
</body>
</html>
  }
  if(bHit){
    B.id = bHit; B.type = 'anxiety';
    B.a = ans[bHit+'a']; B.b = ans[bHit+'b']; B.c = ans[bHit+'c'];
  }

  // C：若 A 主问题全否才会有 C1，这里只记录选项
  if(ans['C1']){ C.id = 'C1'; C.choice = ans['C1']; }

  // —— 选择故事键（优先级：若 B 和 C 同时存在 → 用 B；否则 A 优先，其次 B，其次 C） ——
  let key = null, label = '';
  if(B.id && C.id){ key = B.id; label = '焦虑原型 '+B.id; }
  else if(aHit){ key = A.id; label = '身份原型 '+A.id; }
  else if(B.id){ key = B.id; label = '焦虑原型 '+B.id; }
  else if(C.id){ key = C.id; label = '伪归类 '+C.id; }

  // —— 故事模板：请把 15 篇中文故事填到下方（占位） ——
  const T = {
    // A 类示例：把 [A1a特征] / [A1b特征] / [A1c特征] 替换为对应补充答案
    A1: `她第一次来我们办公室的时候，大家都说她很有礼貌，说话轻声细语，穿着合身，笑起来像谁都不会拒绝的人。\n领导很喜欢她，说她“像我们这行该有的样子”。她从不迟到，桌子永远整整齐齐，午饭吃得不多，话也不多。\n有时候我偷偷看她自拍：角度永远一样，下巴朝镜头对齐，[A1a特征]，[A1c特征]。\n她和谁都处得很好，只是没人见过她真正生气，或者真正开心。她每一次笑都像是按下某种按钮才启动的。[A1b特征]。\n有天晚上我们加班，办公室只剩我和她。我走过去想问她要不要一起走，结果看到她正在镜子前低头调整什么。不是妆容，不是衣领——是脸。\n她把脸从脸上慢慢剥下来，从额头撕开，再一寸一寸地卷到下巴。里面是空的。只有白白的塑料架子，像模特头。\n她回头的时候，那张脸正挂在手里，可她还在笑。和照片里一模一样的笑。`,

    A2: ``,
    A3: ``,
    A4: ``,
    A5: ``,
    A6: ``,

    // B 类故事（会用 [Bxa] / [Bxb] / [Bxc] 替换）
    B1: ``,
    B2: ``,
    B3: ``,
    B4: ``,
    B5: ``,
    B6: ``,

    // C 类故事（示例：用 [C1选项] 占位）
    C1: ``
  };

  // —— 根据 key 与补充项进行占位替换 ——
  function renderStory(){
    const who = document.getElementById('who');
    const tag = document.getElementById('tag');
    const storyBox = document.getElementById('story');
    const meta = document.getElementById('meta');

    who.textContent = `${name} · 你的故事`;
    tag.textContent = label || '未归类';

    if(!key || !T[key]){
      storyBox.textContent = '（没有找到可用的故事模板。请返回上一页重新作答，或联系作者补充 15 篇故事文本。）';
      meta.textContent = '';
      return;
    }

    let txt = T[key];

    if(key.startsWith('A')){
      // 将 [Axa特征] 占位替换成答案
      txt = txt
        .replaceAll(`[${key}a特征]`, A.a||'')
        .replaceAll(`[${key}b特征]`, A.b||'')
        .replaceAll(`[${key}c特征]`, A.c||'');
    } else if(key.startsWith('B')){
      txt = txt
        .replaceAll(`[${key}a]`, B.a||'')
        .replaceAll(`[${key}b]`, B.b||'')
        .replaceAll(`[${key}c]`, B.c||'');
    } else if(key === 'C1'){
      txt = (T[key]||'').replaceAll('[C1选项]', C.choice||'');
    }

    // 渲染，带“红丝带”高亮方括号段
    storyBox.innerHTML = decorate(txt);

    // 元信息
    const answered = payload.totalAsked!=null ? payload.totalAsked : Object.keys(ans).length;
    const ids = Object.keys(ans).join(' · ');
    meta.textContent = `已答题：${answered} 题｜身份原型：${A.id||'—'}｜焦虑原型：${B.id||'—'}｜C1：${C.choice||'—'}`;
  }

  // 将中括号内容包一个“丝带” span（视觉更像海报标题）
  function decorate(s){
    return s
      .replace(/\n/g, '<br/>')
      .replace(/\[(.*?)\]/g, (m,p1)=> `<span class="ribbon">${p1}</span>`);
  }

  renderStory();

  // —— 保存为图片（简单用 html2canvas 的无依赖方案：使用 CSS Paint? 为简洁起见，这里用浏览器内置截图快捷键即可。占位按钮可自定义逻辑。） ——
  document.getElementById('saveBtn').addEventListener('click', ()=>{
    alert('提示：按系统截图快捷键保存当前海报。若需要自动导出图片/海报 PDF，我可以再给你加上 html2canvas/Canvas 导出版本。');
  });
  </script>
</body>
</html>
